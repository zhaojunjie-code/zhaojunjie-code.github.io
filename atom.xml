<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhaojunjie-code.github.io/</id>
    <title>杰</title>
    <updated>2021-04-07T13:52:20.397Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhaojunjie-code.github.io/"/>
    <link rel="self" href="https://zhaojunjie-code.github.io/atom.xml"/>
    <subtitle>前端探索</subtitle>
    <logo>https://zhaojunjie-code.github.io/images/avatar.png</logo>
    <icon>https://zhaojunjie-code.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 杰</rights>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-数据、方法、数据绑定]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/">
        </link>
        <updated>2021-04-07T12:51:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据">数据</h1>
<pre><code class="language-javascript">var data = { a: 1 }
var vm = new Vue({
 data: data
})
vm.$data === data // -&gt; true
vm.a === data.a // -&gt; true
// 设置属性也会影响到原始数据
vm.a = 2
data.a // -&gt; 2
// 反之亦然
data.a = 3
vm.a // -&gt; 3
</code></pre>
<p>如上，当在模板中使用{{a}},也会得到vm.a，修改vm.a，模板中的{{a}},也会改变，这称为</p>
<h3 id="响应式数据">响应式数据</h3>
<p>只有在初始化后的数据，才是响应式的，初始化后，再加入vm.b，这样不会有响应</p>
<h1 id="方法">方法</h1>
<h2 id="通过选型属性methods定义方法并通过v-on指令监听dom事件">通过选型属性methods:{},定义方法，并通过v-on指令监听DOM事件</h2>
<pre><code class="language-javascript">&lt;button v-on:click=&quot;alert&quot;/&gt;alert&lt;button&gt;
new Vue({
el : '#app',
data : { a : 1},
methods : {
　　 alert : function() {
　　　 alert(this.a);
　　 }
}
});
</code></pre>
<h1 id="数据绑定">数据绑定</h1>
<p>1.文本插值<br>
{{文本插值}}<br>
2.HTML属性</p>
<pre><code class="language-javascript">&lt;div id=&quot;id-{{id}}&quot;&gt;&lt;/div&gt; // &lt;div id=&quot;id-1&quot;&gt;&lt;/div&gt;
</code></pre>
<p>3.绑定表达式</p>
<pre><code class="language-javascript">{{ index + 1 }} // 1
{{ index == 0 ? 'a' : 'b'}} // a
{{ name.split('').join('|') }} // V|u|e
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-模板]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/">
        </link>
        <updated>2021-04-07T12:23:59.000Z</updated>
        <content type="html"><![CDATA[<p>Vue.js的使用都是通过构造函数Vue({option})，创建一个Vue实例：</p>
<pre><code class="language-javascript">var vm = new Vue({
    el:                           //挂载html元素，准备操作它
    template:
})
</code></pre>
<h2 id="el-用来为实例提供挂载元素">el 用来为实例提供挂载元素</h2>
<pre><code>el:'#app'
</code></pre>
<h2 id="默认将template值它的值一般都是html语句替换挂载元素即el对应的元素">默认将template值，(它的值一般都是html语句)替换挂载元素，即(el)对应的元素</h2>
<h3 id="class合并挂载元素和模板根节点的属性-id则以模板根节点为属性">(class)合并挂载元素和模板根节点的属性, (id)则以模板根节点为属性</h3>
<p>因为要在为template赋html语句。这样影响可读性<br>
一般</p>
<pre><code class="language-javascript">&lt;div id=&quot;app&quot;&gt;
&lt;p&gt;123&lt;/p&gt;
&lt;/div&gt;
&lt;script id=&quot;tpl&quot; type=&quot;x-template&quot;&gt;           //script1
&lt;div&gt;
　　 &lt;p&gt;This is a tpl from script tag&lt;/p&gt;
&lt;/div&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;                  //script2
var vm = new Vue({
　　 el : '#app',
　　 template : '#tpl'                    //取自于script1
});
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue组件]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-zu-jian/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-zu-jian/">
        </link>
        <updated>2021-04-07T04:11:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="组件是一个拥有预定义选项的一个vue实例">组件是一个拥有预定义选项的一个Vue实例</h1>
<p>定义语句<br>
Vue.component(&quot;组件的名字(字符串),以对象的形式描述一个组件)</p>
<pre><code class="language-javaScript">&lt;html&gt;
&lt;body&gt;
    &lt;div id=&quot;app9&quot;&gt;
        &lt;button-counter&gt;&lt;/button-counter&gt;          &lt;!--组件标签--&gt;
    &lt;/div&gt;
&lt;\body&gt;
&lt;\html&gt;
&lt;script&gt;
        Vue.component('button-counter', {             //Vue组件
            data: function () {   //on:click响应函数
                return {
                    count: 0     //初始化默认
                }
            },
            template: &quot;&lt;button v-on:click='count++'&gt;你点击了{{count}}次&lt;/button&gt;&quot;    //模板,使组件标签拥有模板的作用，我们看到模板是一个button标签，里面自带Vue的v-on绑定函数，让count++，函数在上面的DATA域
        })
        var app9 = new Vue({              //创建Vue对象
            el: &quot;#app9&quot;,                          //元素截获
            data: {                                     //数据对象

            }
        });
&lt;\script&gt;       
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AJAX]]></title>
        <id>https://zhaojunjie-code.github.io/post/ajax/</id>
        <link href="https://zhaojunjie-code.github.io/post/ajax/">
        </link>
        <updated>2021-04-06T13:33:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一天">第一天</h1>
<h2 id="xmlhttprequest对象-ajax的开始">* XMLHttpRequest对象 AJAX的开始</h2>
<pre><code class="language-javaScript">var xmlhttp;
xmlhttp = new XMLHttpRequest();
</code></pre>
<h2 id="向服务器发送请求">向服务器发送请求</h2>
<pre><code class="language-javaScript">xmlhttp.open(method,url,async);
xmlhttp.send(string);
</code></pre>
<p>method: 请求的类型 &quot;GET&quot; OR &quot;POST&quot;<br>
url: 文件在服务器的位置<br>
async：true（异步）false（同步）</p>
<p>string: 仅用于POST请求</p>
<h3 id="当使用get发送信息时发送的信息写在url里面-send">当使用GET发送信息时，发送的信息写在url里面 send()</h3>
<h3 id="当使用post发送信息时发送的信息写在send写在这里">当使用POST发送信息时，发送的信息写在send(写在这里)</h3>
<h3 id="setrequsetheaderheadervalue">setRequsetHeader(header，value)</h3>
<p>添加HTTP头<br>
header: 规定头的名称<br>
value： 规定头的值</p>
<h2 id="服务器响应">服务器响应</h2>
<h4 id="responsetext-获得字符串形式的响应数据">responseText 获得字符串形式的响应数据</h4>
<h4 id="responsexml-获得xml形式的响应数据">responseXML 获得XML形式的响应数据</h4>
<p>通常不是XML，就使用Text</p>
<pre><code class="language-javaScript">document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
</code></pre>
<p>如果是XML,则</p>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script&gt;
function loadXMLDoc()
{
  var xmlhttp;
  var txt,x,i;
  if (window.XMLHttpRequest)
  {
    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();
  }
  else
  {
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  xmlhttp.onreadystatechange=function()
  {
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
    {
      xmlDoc=xmlhttp.responseXML;
      txt=&quot;&quot;;
      x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);
      for (i=0;i&lt;x.length;i++)
      {
        txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;
      }
      document.getElementById(&quot;myDiv&quot;).innerHTML=txt;
    }
  }
  xmlhttp.open(&quot;GET&quot;,&quot;cd_catalog.xml&quot;,true);
  xmlhttp.send();
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;h2&gt;我收藏的 CD :&lt;/h2&gt;
&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;
&lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;获取我的 CD&lt;/button&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="onreadystatechange-事件-通常被绑定一个服务器响应函数">onreadystatechange 事件 通常被绑定一个服务器响应函数</h2>
<p>当open,send这些请求发送到服务器是，，服务器会返回响应<br>
onreadystatechange事件类似与onclick事件<br>
每当鼠标点击会触发onclick事件</p>
<h4 id="每当readystate改变时onreadystatechage会被触发一次">每当readyState改变时，onreadystatechage会被触发一次</h4>
<h3 id="readystate-存有xmlhttprequest的状态0-4之间变化">readyState  存有XMLHttpRequest的状态，0-4之间变化</h3>
<p>0：请求未初始化<br>
1：服务器连接已建立<br>
2：请求已接收<br>
3：请求处理中<br>
4：请求已完成，且响应已就绪</p>
<h3 id="status-存储状态">status 存储状态</h3>
<p>200：&quot;OK&quot;<br>
404: 未找到页面<br>
在onreadystatechange事件中，当readyState等于4且状态为200，表示响应就绪</p>
<pre><code class="language-javaScript">if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)     //当服务器响应成功
    {
        document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;   //前端要干的事
    }
</code></pre>
<h3 id="回调函数">回调函数</h3>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
var xmlhttp;
function loadXMLDoc(url,cfunc)
{
if (window.XMLHttpRequest)
  {// IE7+, Firefox, Chrome, Opera, Safari 代码
  xmlhttp=new XMLHttpRequest();
  }
else
  {// IE6, IE5 代码
  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
xmlhttp.onreadystatechange=cfunc;
xmlhttp.open(&quot;GET&quot;,url,true);
xmlhttp.send();
}
function myFunction()
{
	loadXMLDoc(&quot;/try/ajax/ajax_info.txt&quot;,function()             //调用上面的函数
	{
		if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
		{
			document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
		}
	});
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;使用 AJAX 修改文本内容&lt;/h2&gt;&lt;/div&gt;
&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;修改内容&lt;/button&gt;    //绑定自己调用的函数

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="与后台交互-documentgetelementbyidtxthintinnerhtmlxmlhttpresponsetext">与后台交互 document.getElementById(&quot;txtHint&quot;).innerHTML=xmlhttp.responseText;</h2>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script&gt;
function showCustomer(str)
{
  var xmlhttp;    
  if (str==&quot;&quot;)                 //开始状态，或者没有值
  {
    document.getElementById(&quot;txtHint&quot;).innerHTML=&quot;&quot;;
    return;               //直接结束
  }
  if (window.XMLHttpRequest)
  {
    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();            //创建一个XMLHttpRequest对象
  }
  else
  {
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/getcustomer.php?q=&quot;+str,true);   //通过GET方法向服务器请求（发送的信息就在url后面加上）这里是 &quot;...q=&quot; +str
  xmlhttp.send();
  xmlhttp.onreadystatechange=function()     //绑定服务器响应函数  ，根据readyState的变化，调用onreadystatechange
  {
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    //响应成功的标志
    {
      document.getElementById(&quot;txtHint&quot;).innerHTML=xmlhttp.responseText;    //从服务器得到数据
    }
  }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;form action=&quot;&quot;&gt; 
&lt;select name=&quot;customers&quot; onchange=&quot;showCustomer(this.value)&quot; style=&quot;font-family:Verdana, Arial, Helvetica, sans-serif;&quot;&gt;   //下拉列表
&lt;option value=&quot;APPLE&quot;&gt;Apple Computer, Inc.&lt;/option&gt;
&lt;option value=&quot;BAIDU &quot;&gt;BAIDU, Inc&lt;/option&gt;
&lt;option value=&quot;Canon&quot;&gt;Canon USA, Inc.&lt;/option&gt;
&lt;option value=&quot;Google&quot;&gt;Google, Inc.&lt;/option&gt;
&lt;option value=&quot;Nokia&quot;&gt;Nokia Corporation&lt;/option&gt;
&lt;option value=&quot;SONY&quot;&gt;Sony Corporation of America&lt;/option&gt;
&lt;/select&gt;
&lt;/form&gt;
&lt;br&gt;
&lt;div id=&quot;txtHint&quot;&gt;客户信息将显示在这...&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS实现完美的拖拽]]></title>
        <id>https://zhaojunjie-code.github.io/post/js-shi-xian-wan-mei-de-tuo-zhuai/</id>
        <link href="https://zhaojunjie-code.github.io/post/js-shi-xian-wan-mei-de-tuo-zhuai/">
        </link>
        <updated>2021-04-02T08:19:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="预备知识">预备知识</h1>
<p>##event事件对象</p>
<h3 id="与光标有关的属性-clientx">与光标有关的属性 clientX</h3>
<p>返回当事件被触发时，鼠标的水平坐标(距离 px)</p>
<h3 id="与光标有关的属性-clienty">与光标有关的属性 clientY</h3>
<p>返回当事件被触发时，鼠标的垂直坐标(距离 px)</p>
<h2 id="html元素对象">HTML元素对象</h2>
<h3 id="offsetleft">offsetLeft</h3>
<p>当前元素相对与最近定位的父元素的水平距离(px)</p>
<h3 id="offsettop">offsetTop</h3>
<p>当前元素相对与最近定位的父元素的垂直距离(px)</p>
<h1 id="跟随鼠标">跟随鼠标</h1>
<p>每当提到控制DOM跟随鼠标移动，我们头脑里会蹦出PageX,PageY 它们俩分别返回当前光标的水平坐标和垂直坐标。</p>
<pre><code class="language-javaScript">var left = event.pageX;
var top = event.pageY;
box1.style.left = left + &quot;px&quot;;
box1.style.top = top +&quot;px&quot;;
</code></pre>
<p>这很容易实现</p>
<h2 id="当我们将上述操作应用到拖拽操作时">当我们将上述操作应用到拖拽操作时</h2>
<p>我们会发现，点击一个元素的某一位置进行拖拽时，元素总会跳变到跟随鼠标移动的位置<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617353505592.png" alt="" loading="lazy"><br>
这导致用户体验感极差<br>
如何解决这个问题呢？<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617354112330.png" alt="" loading="lazy"><br>
我们可以看到</p>
<h3 id="clientx-offsetleft-水平跳变距离">clientX - offsetLeft = 水平跳变距离</h3>
<h3 id="同理-clienty-offsettop-垂直跳变距离">同理 clientY - offsetTop = 垂直跳变距离</h3>
<pre><code class="language-javaScript">box1.onmousedown = function (event) {
               var ol = event.clientX - box1.offsetLeft;
               var ot = event.clientY - box1.offsetTop;
               document.onmousemove = function (event) {
                   var X = event.pageX - ol;
                   var Y = event.pageY - ot;
                   box1.style.left = X + &quot;px&quot;;
                   box1.style.top = Y + &quot;px&quot;;
               }
           }
</code></pre>
<p>我们不希望看到跳变，那么就减去跳变距离</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS实现先阅读协议，后注册]]></title>
        <id>https://zhaojunjie-code.github.io/post/js-shi-xian-xian-yue-du-xie-yi-hou-zhu-ce/</id>
        <link href="https://zhaojunjie-code.github.io/post/js-shi-xian-xian-yue-du-xie-yi-hou-zhu-ce/">
        </link>
        <updated>2021-04-01T11:42:37.000Z</updated>
        <content type="html"><![CDATA[<p>每当我们想注册账号，或者安装软件时，总有一些细致严谨的公司，他们让你在安装前阅读长长的协议。这背后的原理是什么呢？<br>
我们先应该了解JS里的 scrollHeight(文档内容实际高度，包括超出视窗的溢出部分)，scrollTop(滚动条相对于文档顶部的高度，即：滚动距离)，clientHeight(窗口的高度) 属性。</p>
<h1 id="scrollheight">scrollHeight()</h1>
<p>scrollHeight()是window的属性<br>
它是指：文档内容的实际高度，一个网页从页头到页尾。</p>
<h1 id="scrolltop">scrollTop()</h1>
<p>scrollTop()也是window的属性<br>
它是指：垂直滚动条滚动的距离，滚动条下拉的距离。</p>
<h1 id="clientheight">clientHeight()</h1>
<p>clientHeight()是window的属性<br>
翻译过来就很理解：用户所能看到的高度。<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617280221051.png" alt="" loading="lazy"><br>
现在我们应该可以理解背后的原理了吧</p>
<h1 id="就是当红框框到底的时候即-scrollheight-scrolltop-clientheight">就是当红框框到底的时候，即       scrollHeight - scrollTop = clientHeight</h1>
<pre><code class="language-javaScript">					//检查垂直滚动条是否滚动到底
 				if(info.scrollHeight - info.scrollTop == info.clientHeight){
 					//滚动条滚动到底，使表单项可用
 					/*
 					 * disabled属性可以设置一个元素是否禁用，
 					 * 	如果设置为true，则元素禁用
 					 * 	如果设置为false，则元素可用
 					 */
 					inputs[0].disabled = false;
 					inputs[1].disabled = false;
 				}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次使用Gridea]]></title>
        <id>https://zhaojunjie-code.github.io/post/di-yi-ci-shi-yong-gridea/</id>
        <link href="https://zhaojunjie-code.github.io/post/di-yi-ci-shi-yong-gridea/">
        </link>
        <updated>2021-03-31T16:05:56.000Z</updated>
        <content type="html"><![CDATA[<p>2021/4/1 0:08<br>
终于写下了第一篇博客，为前端的学习做好了准备<br>
<em>斜体字</em><br>
<strong>粗体字</strong><br>
<em><strong>粗斜体文本</strong></em><br>
<em>插入斜线</em></p>
<hr>
<p><s>删除文字</s><br>
<u>带上下划线</u><br>
<em>添加脚注</em><br>
长沙理工大学<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>有序列表与无序列表，一定要有一个空格</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第三项</li>
<li>第四项</li>
<li>第五项</li>
</ul>
<ul>
<li>第六项</li>
<li>第七项</li>
<li>第八项</li>
</ul>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
<li>第四项，嵌套使用
<ul>
<li>新的一项，要留四个空格</li>
<li>新的一项，要留四个空格</li>
</ul>
</li>
</ol>
<blockquote>
<p>区块</p>
<blockquote>
<p>第一次嵌套</p>
<blockquote>
<p>第二次嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
</blockquote>
<p>列表中使用区块</p>
<ol>
<li>
<p>第一项</p>
<blockquote>
<p>第一区块<br>
第二区块<br>
第三区块</p>
</blockquote>
</li>
<li>
<p>第二项</p>
<blockquote>
<p>第一区块<br>
第二区块<br>
第三区块</p>
</blockquote>
</li>
</ol>
<p>代码区块,三个漂符，可以指定语言也可不指定语言<br>
<code>printf()</code> 函数</p>
<pre><code class="language-javaScript">$(document).ready(function () {
    alert('RUNOOB');
});
</code></pre>
<p>基本的链接使用方法<br>
这是一个<a href="https://www.runoob.com">菜鸟教程</a>的链接<br>
高级使用方法<br>
用1设置链接变量<br>
这是一个链接 [菜鸟教程][1]<br>
[1]:  https://www.runoob.com/<br>
两种显示出图片的方法<br>
<img src="http://static.runoob.com/images/runoob-logo.png" alt="这里填显示不出来的代替文字" loading="lazy"><br>
<img src="http://static.runoob.com/images/runoob-logo.png" width="50%"></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>双非大学 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>