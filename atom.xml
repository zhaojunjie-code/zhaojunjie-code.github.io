<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhaojunjie-code.github.io/</id>
    <title>杰</title>
    <updated>2021-04-17T10:32:10.750Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhaojunjie-code.github.io/"/>
    <link rel="self" href="https://zhaojunjie-code.github.io/atom.xml"/>
    <subtitle>前端探索</subtitle>
    <logo>https://zhaojunjie-code.github.io/images/avatar.png</logo>
    <icon>https://zhaojunjie-code.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 杰</rights>
    <entry>
        <title type="html"><![CDATA[CSS选择器]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-xuan-ze-qi/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-xuan-ze-qi/">
        </link>
        <updated>2021-04-17T10:24:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="后代选择器-空格">后代选择器: 空格</h1>
<p>很简单，例如div p {？} ：这说明div下的所有p后代都需要有？这个效果</p>
<h1 id="子选择器">子选择器: &gt;</h1>
<p>div&gt;p{} 说明那些唯一爸爸是div的p才拥有效果，不能是爷爷，曾爷爷</p>
<h1 id="相邻兄弟选择器">相邻兄弟选择器: +</h1>
<p>div +p {}</p>
<pre><code class="language-js">&lt;div&gt;
  &lt;p&gt;div 中的段落 1。&lt;/p&gt;
  &lt;p&gt;div 中的段落 2。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;段落 3。不在 div 中。&lt;/p&gt;
</code></pre>
<p>p与div同级且相邻且p在div 后面出现</p>
<h1 id="通用兄弟选择器-~">通用兄弟选择器: ~</h1>
<p>div~p{}<br>
选中与div同级的p</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS定位机制]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-ding-wei-ji-zhi/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-ding-wei-ji-zhi/">
        </link>
        <updated>2021-04-17T09:16:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="css有三种定位机制-普通流浮动绝对定位">CSS有三种定位机制 普通流，浮动，绝对定位</h1>
<h2 id="普通流由html位置决定块级框一个接一个排列框之间的垂直距离是由框的垂直外边计算出来的行内框在一行中水平布置水平内边距-边框和外边距调整它们的间距垂直边距边框距不会改变其高度">普通流:由HTML位置决定，块级框一个接一个排列，框之间的垂直距离是由框的垂直外边计算出来的；行内框在一行中水平布置，水平内边距、边框和外边距调整它们的间距，垂直边距，边框距不会改变其高度。</h2>
<h2 id="定位-相对定位-relative">定位-相对定位 relative</h2>
<h3 id="positonrelative其元素并不会脱离文档流而是还出现在相对定位之前的位置但是可以通过topleftrightbottom设置其偏移距离注意它一直在文档流中仍然占据原来的空间-移动后会覆盖其他的框">positon:relative;其元素并不会脱离文档流，而是还出现在相对定位之前的位置，但是可以通过top,left,right,bottom设置其偏移距离，注意：它一直在文档流中，仍然占据原来的空间。移动后会覆盖其他的框</h3>
<figure data-type="image" tabindex="1"><img src="https://zhaojunjie-code.github.io//post-images/1618652538672.PNG" alt="" loading="lazy"></figure>
<h3 id="positonabsolute其元素会从文档流中删除并相对于一个已经定位的包含块定位如果没有包含块则相对于初始块定位元素原先在文档流中占据的空间会被浏览器关闭他之后的元素可能会上来补他的位置-元素定位后生成一个块级框而不论原来它在正常流中生成何种类型的框">positon:absolute;其元素会从文档流中删除，并相对于一个已经定位的包含块定位(如果没有包含块，则相对于初始块定位)，元素原先在文档流中占据的空间会被浏览器关闭，他之后的元素可能会上来补他的位置。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</h3>
<figure data-type="image" tabindex="2"><img src="https://zhaojunjie-code.github.io//post-images/1618652786818.PNG" alt="" loading="lazy"></figure>
<h2 id="浮动float">浮动float</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web前端方向]]></title>
        <id>https://zhaojunjie-code.github.io/post/web-qian-duan-fang-xiang/</id>
        <link href="https://zhaojunjie-code.github.io/post/web-qian-duan-fang-xiang/">
        </link>
        <updated>2021-04-16T00:41:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="就业">就业</h1>
<h2 id="一-春招时间3-4月">一、春招时间：3-4月</h2>
<h2 id="二-学习内容">二、学习内容</h2>
<ul>
<li>html/css</li>
<li><strong>JavaScript（ES5、ES6）</strong></li>
<li>框架（React或者Vue）</li>
<li>浏览器工作原理与实践</li>
<li>计算机网络（重点是HTTP、TCP）</li>
<li>数据结构与算法</li>
</ul>
<h2 id="三-简历准备">三、简历准备</h2>
<ul>
<li>博客
<ul>
<li>Typora</li>
<li>Markdown</li>
<li>Gridea</li>
</ul>
</li>
<li>项目
<ul>
<li>实训项目
<ul>
<li>node.js
<ul>
<li>链接：https://pan.baidu.com/s/1BHMKAQ_7sS8BnlOrcl8BUg<br>
提取码：ywva<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
</ul>
</li>
<li>比赛项目</li>
</ul>
</li>
</ul>
<h2 id="四-学习资料">四、学习资料</h2>
<ul>
<li>JavaScript
<ul>
<li>JavaScript高级程序设计（ES5）
<ul>
<li>音频教程：https://www.ximalaya.com/gerenchengzhang/3740790/</li>
</ul>
</li>
<li>ECMAScript 6入门
<ul>
<li>https://es6.ruanyifeng.com/#README</li>
</ul>
</li>
</ul>
</li>
<li>计算机网络
<ul>
<li>图解TCP/IP</li>
<li>图解HTTP</li>
<li>计算机网络自顶向下</li>
<li><strong>透视HTTP</strong>
<ul>
<li>链接：https://pan.baidu.com/s/1SI8bD0t9VI29qJgZdrcAug<br>
提取码：pe41<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
</ul>
</li>
<li>浏览器工作原理与实践
<ul>
<li>链接：https://pan.baidu.com/s/1gO05ERziH9r3aYoKuZA9sw<br>
提取码：8wqy<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
<li>数据结构与算法
<ul>
<li>Leetcode</li>
<li>牛客（剑指offer）</li>
</ul>
</li>
<li>搜索
<ul>
<li>掘金</li>
<li>思否</li>
<li>知乎</li>
<li>MDN</li>
</ul>
</li>
<li>面试
<ul>
<li>牛客</li>
<li>实习僧</li>
<li>拉钩</li>
<li>Boss直聘</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS中级总结]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-zhong-ji-zong-jie/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-zhong-ji-zong-jie/">
        </link>
        <updated>2021-04-12T12:39:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="display属性">display属性</h1>
<p>如何显示一个元素：block，inline<br>
首先要了解块级元素：占据一行的宽度<br>
div,h1-h6,p,form,header,footer,section</p>
<p>行内元素：占据所需的宽度<br>
span,a,img</p>
<h2 id="覆盖默认的display值">覆盖默认的display值</h2>
<p>li{display:inline;}  li本来是块级元素，强制将其转变为行内元素<br>
span{display:block;}span本来是行内元素，强制将其转变为块级元素<br>
注意这种强制转换为行内元素的标签，是不能为其设置高度的</p>
<h2 id="displaynone-通常与js用来隐藏显示元素-该元素的位置会被其他元素占据">display:none 通常与JS用来隐藏显示元素 该元素的位置会被其他元素占据</h2>
<pre><code class="language-javascript">document.getelementById(&quot;btn01).onclick = function(){  //为按钮绑定单击响应函数
      document.getelementById(&quot;box01).style.display = &quot;none&quot;;
}
</code></pre>
<h2 id="visibilityhidden指定元素是否可见元素所占据的位置还是存在">visibility：hidden指定元素是否可见，元素所占据的位置还是存在</h2>
<h1 id="position定位">position定位</h1>
<h2 id="static浏览器为其自动安排位置">static:浏览器为其自动安排位置</h2>
<h2 id="relative元素相对于其正常位置进行定位这时要用上lefttopbottom">relative:元素相对于其正常位置进行定位；这时要用上left:;top:;bottom:;</h2>
<h2 id="fixed相对于屏幕定位鼠标滚动页面它始终处于同一位置">fixed:相对于屏幕定位，鼠标滚动页面，它始终处于同一位置</h2>
<h2 id="absolute相对于最近的定位了的祖先元素进行定位-如果没有祖先则使用文档主体并随页面滚动">absolute：相对于最近的定位了的祖先元素进行定位。如果没有祖先，则使用文档主体，并随页面滚动。</h2>
<p>&quot;定位了的祖先&quot;:除了static属性以外的其他属性fixed,relative...都可以被定义为&quot;定位了的祖先&quot;</p>
<h2 id="fixed粘性定位-粘性定位开始并不是粘性定位而是relative直到至少给定一个topleft来指明什么时侯开始成为粘性定位">fixed:粘性定位。粘性定位开始并不是粘性定位，而是relative；直到至少给定一个top,left,...来指明什么时侯开始成为粘性定位。</h2>
<h2 id="z-index重叠定位">z-index重叠定位</h2>
<p>用来确定重叠的元素，呈现给用户的顺序。<br>
z-index=-1 堆叠顺序较低，所以成为了背景板<br>
z-index越高，则越是主角</p>
<h1 id="overflow-溢出指在内容太大而无法放在指定区域用来决定是裁剪还是添加滚动条">overflow 溢出：指在内容太大而无法放在指定区域，用来决定是裁剪还是添加滚动条</h1>
<h2 id="visible默认溢出就溢出在外面接着渲染">visible:默认，溢出就溢出，在外面接着渲染</h2>
<h2 id="hidden裁剪溢出部分不要了">hidden:裁剪，溢出部分不要了</h2>
<h2 id="scroll加滚动条">scroll:加滚动条</h2>
<h1 id="float浮动">float浮动</h1>
<h2 id="inherit继承父级float值">inherit继承父级float值</h2>
<h1 id="clear清除">clear清除</h1>
<p>##none：允许两侧都有浮动元素   会出现不浮动元素嵌入到浮动元素下面</p>
<h2 id="left左侧不允许浮动元素左侧被管制-如果">left：左侧不允许浮动元素，左侧被管制   如果</h2>
<h2 id="right同上">right：同上</h2>
<h2 id="both左侧或右侧不允许浮动元素">both：左侧或右侧不允许浮动元素</h2>
<h2 id="inherit继承父级的clear">inherit：继承父级的clear</h2>
<h2 id="清除原理-一个div1左浮动另一个div2不浮动则会出现给用户这样的情况div2出现在div1的下面当div2使用clearleft时浏览器检查div2发现其左侧有div1在浮动他会清除这种效果本来div1是左漂浮起来了div2在其下面浏览器将div1的投影也占位div2自然而然就跑到了div1的一下一行注意float与clear是对应的div1-floatleft-那么div2-clearleft这样才会起作用">清除原理： 一个div1左浮动，另一个div2不浮动；则会出现给用户这样的情况，div2出现在div1的下面，当div2使用clear:left;时，浏览器检查div2，发现其左侧有div1在浮动，他会清除这种效果(本来div1是左漂浮起来了，div2在其下面，浏览器将div1的投影也占位，div2自然而然就跑到了div1的一下一行)注意float与clear是对应的div1 float:left 那么div2 clear:left这样才会起作用</h2>
<h1 id="box-sizingborder-box-强制限制内边距和边框的厚度不能撑开盒子除非内边距和边框厚度设置的太离谱为了保证内容盒子会被放大">box-sizing:border-box; 强制限制内边距和边框的厚度不能撑开盒子(除非内边距和边框厚度设置的太离谱，为了保证内容，盒子会被放大)</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS基础总结]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-zong-jie/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-zong-jie/">
        </link>
        <updated>2021-04-12T06:06:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="background">background</h1>
<h2 id="background-image-背景图">background-image 背景图</h2>
<p>默认情况下background-image属性在水平和垂直方向上都重复的图像</p>
<h2 id="background-repeat-设置重复方向">background-repeat  设置重复方向</h2>
<p>repeatx:水平方向重复<br>
repeaty:垂直方向上重复<br>
no-repeat:不重复</p>
<h2 id="background-position-设置图片位置">background-position  设置图片位置</h2>
<p>right top :右上角</p>
<h2 id="background-attachment-设置图片附着">background-attachment 设置图片附着</h2>
<p>fixed:一直附着在网页上，随着鼠标滚动 client右上角<br>
scroll:不随鼠标滚动，定死在右上角<br>
简写</p>
<pre><code class="language-css">body {
background: #ffffff url(&quot;tree.png&quot;) no-repeat right top;  //注意顺序 颜色，背景图，重复，位置
}
</code></pre>
<h1 id="border">border</h1>
<h2 id="border-style-设置边框的类型">border-style 设置边框的类型</h2>
<p>dotted - 定义点线边框<br>
*dashed - 定义虚线边框<br>
*solid - 定义实线边框<br>
double - 定义双边框<br>
groove - 定义 3D 坡口边框。效果取决于 border-color 值<br>
ridge - 定义 3D 脊线边框。效果取决于 border-color 值<br>
inset - 定义 3D inset 边框。效果取决于 border-color 值<br>
outset - 定义 3D outset 边框。效果取决于 border-color 值<br>
none - 定义无边框<br>
hidden - 定义隐藏边框</p>
<h2 id="border-width-边框宽度">border-width 边框宽度</h2>
<p>medium,thick,<br>
还可设置四个值(上右下左)，可以设置个边的长度</p>
<h2 id="border-color-边框颜色">border-color 边框颜色</h2>
<p>同上</p>
<h2 id="border-radius-添加圆角">border-radius 添加圆角</h2>
<p>radius越大，左右边框越圆</p>
<h1 id="margin-外边距">margin 外边距</h1>
<h2 id="toprightbottomleft">top;right,bottom,left</h2>
<p>auto - 浏览器来计算外边距<br>
length - 以 px、pt、cm 等单位指定外边距<br>
% - 指定以包含元素宽度的百分比计的外边距<br>
inherit - 指定应从父元素继承外边距</p>
<h2 id="margin简写">margin简写</h2>
<p>四个值：上，右，下，左<br>
三个值：上，右左，下<br>
两个值：上下，左右<br>
一个值：上右下左<br>
auto:元素在其容器中水平居中，该元素占据指定宽度，并且甚于空间将在左右边界之间平均分配<br>
inherit:</p>
<pre><code class="language-css">div {
  border: 1px solid red;
  margin-left: 100px;
}
p.ex1 {
  margin-left: inherit;      //class=ex1的元素，继承父元素div的外边距，也为margin-left: 100px;
}
</code></pre>
<h2 id="外边距合并">外边距合并</h2>
<h3 id="垂直外边距当两个垂直外边距相遇他们会合并成一个外边距">垂直外边距：当两个垂直外边距相遇，他们会合并成一个外边距</h3>
<p><img src="https://zhaojunjie-code.github.io//post-images/1618209661668.PNG" alt="" loading="lazy"><br>
解释一下：程序员的疏忽，给上面一个盒子设置了下边距，又给下面一个盒子设置了上边距；边距相包含，则浏览器会找出两个边距较大的作为包含后的边距</p>
<h3 id="嵌套外边距合并当两个盒子嵌套在一起父元素没有设置上内边距及边框则父元素的上外边距会与子元素的上外边距合并取较大者">嵌套外边距合并：当两个盒子嵌套在一起，父元素没有设置上内边距及边框，则父元素的上外边距会与子元素的上外边距合并，取较大者</h3>
<figure data-type="image" tabindex="1"><img src="https://zhaojunjie-code.github.io//post-images/1618210496706.PNG" alt="" loading="lazy"></figure>
<h3 id="甚至有空元素设置了上外边距和下外边距上下会合并取较大者">甚至有空元素，设置了上外边距和下外边距，上下会合并，取较大者</h3>
<h3 id="解决方案">解决方案：</h3>
<p>父元素加上 overflow:hidden的解除坍塌功能;<br>
父元素加上边框 border:1px solid transparent设边框加透明，不推荐；<br>
父元素或子元素 浮动或者定位</p>
<h1 id="padding-内边距">padding 内边距</h1>
<p>top,right,bottom,left<br>
length - 以 px、pt、cm 等单位指定内边距<br>
% - 指定以包含元素宽度的百分比计的内边距<br>
inherit - 指定应从父元素继承内边距<br>
基本操作根外边距一样：四个值，三个值，两个值，一个值</p>
<h2 id="padding可以撑大定义的width">padding可以撑大定义的width</h2>
<p>解决方案：box-sizing:border-box；width固定，不允许撑大width</p>
<h1 id="widthheight宽度高度不包括内边距外边距和边框">width,height宽度，高度：不包括内边距，外边距，和边框。</h1>
<p>auto - 默认。浏览器计算高度和宽度。<br>
length - 以 px、cm 等定义高度/宽度。<br>
% - 以包含块的百分比定义高度/宽度。<br>
initial - 将高度/宽度设置为默认值。<br>
inherit - 从其父值继承高度/宽度。</p>
<h2 id="max-width-设置最大宽度">max-width 设置最大宽度</h2>
<p>他的用处是：动态的宽度，随着浏览器窗口大小分配到宽度，但最大不呢个超过max-width</p>
<h1 id="框模型">框模型</h1>
<figure data-type="image" tabindex="2"><img src="https://zhaojunjie-code.github.io//post-images/1618212892530.PNG" alt="" loading="lazy"></figure>
<h1 id="轮廓outline边框之外加一些渲染">轮廓outline：边框之外加一些渲染</h1>
<p>outline-style<br>
outline-color<br>
outline-width 轮廓宽度<br>
outline-offset 轮廓与边框的距离<br>
outline</p>
<pre><code class="language-css"> outline: 1px solid red;
</code></pre>
<h1 id="文本">文本</h1>
<h2 id="color-background-color">color background-color</h2>
<p>字体颜色和背景颜色</p>
<h2 id="text-align-文本对齐">text-align 文本对齐</h2>
<p>center:居中<br>
left:左<br>
right:右<br>
justify:使一段文章的每一行宽度都相等，浏览器会自动的为，不能成为一行的添加空格，凑成一行下图，注意到浏览器自动添加空格，使每一行宽度都一样<br>
<img src="https://zhaojunjie-code.github.io//post-images/1618225316912.PNG" alt="" loading="lazy"></p>
<h2 id="direction文本方向">direction文本方向</h2>
<p>ltr:left to right    默认方向：从左向右  左对齐<br>
rtl:right to left  自定义方向：从左向右 右对齐<br>
inherit：继承父元素的方向</p>
<h2 id="unicode-bidi-用于同一个页面里存在从不同方向读进的文本显示与direction同时使用确定文本方向">unicode-bidi: 用于同一个页面里存在从不同方向读进的文本显示,与direction同时使用，确定文本方向</h2>
<p>有以下的取值<br>
normal:同原来的方向一样<br>
bidi-override:按照direction的值，排序如果是左对齐，就正着来，右对齐就从反着写。<br>
embed:作用于行内元素，按照direction的值决定插入在哪里，正着写</p>
<h2 id="vertical-align-垂直对齐">vertical-align 垂直对齐</h2>
<p>top: 文本顶部对齐<br>
middle:文本中间对齐<br>
bottom:文本底部对齐<br>
<img src="https://zhaojunjie-code.github.io//post-images/1618227261063.PNG" alt="" loading="lazy"><br>
#text-decoration 文本装饰<br>
none:用于从链接上删除下划线<br>
line-through:删除线</p>
<h2 id="text-transform文本转换">text-transform文本转换</h2>
<p>uppercase:大写<br>
lowercase:小写<br>
capitalize:开头字母大写</p>
<h1 id="文字间距">文字间距</h1>
<h2 id="text-indent文字缩进">text-indent文字缩进</h2>
<p>第一行的缩进，写文章时空两个</p>
<h2 id="letter-spacing-字母间距">letter-spacing 字母间距</h2>
<p>指定文本中字符之间的间距<br>
3px:字母与字母之间有3像素的距离<br>
-3px:字母于字母之间缩进3像素的距离</p>
<h2 id="white-space-空白">white-space 空白</h2>
<p>nowrap:禁用元素内文本的换行<br>
#text-shadow 文本阴影<br>
水平阴影，垂直阴影 单位px<br>
#font-size 字体大小<br>
注意的一点就是：1px = 16em<br>
font简写<br>
注意<br>
size和family是必要的，还有style斜体italic；width粗细700</p>
<h1 id="a链接">a链接</h1>
<p>a.link:未访问的链接<br>
a.visited：访问过的链接<br>
a.hover:鼠标放上去时<br>
a.active:链接被点击时</p>
<h1 id="列表">列表</h1>
<p>注意一点<br>
list-style:none;之后，列表依然有边距，可以用margin:0;padding:0;删除边距</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-数据、方法、数据绑定]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/">
        </link>
        <updated>2021-04-07T12:51:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据">数据</h1>
<pre><code class="language-javascript">var data = { a: 1 }
var vm = new Vue({
 data: data
})
vm.$data === data // -&gt; true
vm.a === data.a // -&gt; true
// 设置属性也会影响到原始数据
vm.a = 2
data.a // -&gt; 2
// 反之亦然
data.a = 3
vm.a // -&gt; 3
</code></pre>
<p>如上，当在模板中使用{{a}},也会得到vm.a，修改vm.a，模板中的{{a}},也会改变，这称为</p>
<h3 id="响应式数据">响应式数据</h3>
<p>只有在初始化后的数据，才是响应式的，初始化后，再加入vm.b，这样不会有响应</p>
<h1 id="方法">方法</h1>
<h2 id="通过选择属性methods定义方法并通过v-on指令监听dom事件">通过选择属性methods:{},定义方法，并通过v-on指令监听DOM事件</h2>
<pre><code class="language-javascript">&lt;button v-on:click=&quot;alert&quot;/&gt;alert&lt;button&gt;
new Vue({
el : '#app',
data : { a : 1},
methods : {
　　 alert : function() {
　　　 alert(this.a);
　　 }
}
});
</code></pre>
<h1 id="数据绑定">数据绑定</h1>
<p>1.文本插值<br>
{{文本插值}}<br>
2.HTML属性</p>
<pre><code class="language-javascript">&lt;div id=&quot;id-{{id}}&quot;&gt;&lt;/div&gt; // &lt;div id=&quot;id-1&quot;&gt;&lt;/div&gt;
</code></pre>
<p>3.绑定表达式</p>
<pre><code class="language-javascript">{{ index + 1 }} // 1
{{ index == 0 ? 'a' : 'b'}} // a
{{ name.split('').join('|') }} // V|u|e
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-模板]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/">
        </link>
        <updated>2021-04-07T12:23:59.000Z</updated>
        <content type="html"><![CDATA[<p>Vue.js的使用都是通过构造函数Vue({option})，创建一个Vue实例：</p>
<pre><code class="language-javascript">var vm = new Vue({
    el:                           //挂载html元素，准备操作它
    template:
})
</code></pre>
<h2 id="el-用来为实例提供挂载元素">el 用来为实例提供挂载元素</h2>
<pre><code>el:'#app'
</code></pre>
<h2 id="默认将template值它的值一般都是html语句替换挂载元素即el对应的元素">默认将template值，(它的值一般都是html语句)替换挂载元素，即(el)对应的元素</h2>
<h3 id="class合并挂载元素和模板根节点的属性-id则以模板根节点为属性">(class)合并挂载元素和模板根节点的属性, (id)则以模板根节点为属性</h3>
<p>因为要在为template赋html语句。这样影响可读性<br>
一般</p>
<pre><code class="language-javascript">&lt;div id=&quot;app&quot;&gt;
&lt;p&gt;123&lt;/p&gt;
&lt;/div&gt;
&lt;script id=&quot;tpl&quot; type=&quot;x-template&quot;&gt;           //script1
&lt;div&gt;
　　 &lt;p&gt;This is a tpl from script tag&lt;/p&gt;
&lt;/div&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;                  //script2
var vm = new Vue({
　　 el : '#app',
　　 template : '#tpl'                    //取自于script1
});
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue组件]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-zu-jian/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-zu-jian/">
        </link>
        <updated>2021-04-07T04:11:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="组件是一个拥有预定义选项的一个vue实例">组件是一个拥有预定义选项的一个Vue实例</h1>
<p>定义语句<br>
Vue.component(&quot;组件的名字(字符串),以对象的形式描述一个组件)</p>
<pre><code class="language-javaScript">&lt;html&gt;
&lt;body&gt;
    &lt;div id=&quot;app9&quot;&gt;
        &lt;button-counter&gt;&lt;/button-counter&gt;          &lt;!--组件标签--&gt;
    &lt;/div&gt;
&lt;\body&gt;
&lt;\html&gt;
&lt;script&gt;
        Vue.component('button-counter', {             //Vue组件
            data: function () {   //on:click响应函数
                return {
                    count: 0     //初始化默认
                }
            },
            template: &quot;&lt;button v-on:click='count++'&gt;你点击了{{count}}次&lt;/button&gt;&quot;    //模板,使组件标签拥有模板的作用，我们看到模板是一个button标签，里面自带Vue的v-on绑定函数，让count++，函数在上面的DATA域
        })
        var app9 = new Vue({              //创建Vue对象
            el: &quot;#app9&quot;,                          //元素截获
            data: {                                     //数据对象

            }
        });
&lt;\script&gt;       
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AJAX]]></title>
        <id>https://zhaojunjie-code.github.io/post/ajax/</id>
        <link href="https://zhaojunjie-code.github.io/post/ajax/">
        </link>
        <updated>2021-04-06T13:33:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一天">第一天</h1>
<h2 id="xmlhttprequest对象-ajax的开始">* XMLHttpRequest对象 AJAX的开始</h2>
<pre><code class="language-javaScript">var xmlhttp;
xmlhttp = new XMLHttpRequest();
</code></pre>
<h2 id="向服务器发送请求">向服务器发送请求</h2>
<pre><code class="language-javaScript">xmlhttp.open(method,url,async);
xmlhttp.send(string);
</code></pre>
<p>method: 请求的类型 &quot;GET&quot; OR &quot;POST&quot;<br>
url: 文件在服务器的位置<br>
async：true（异步）false（同步）</p>
<p>string: 仅用于POST请求</p>
<h3 id="当使用get发送信息时发送的信息写在url里面-send">当使用GET发送信息时，发送的信息写在url里面 send()</h3>
<h3 id="当使用post发送信息时发送的信息写在send写在这里">当使用POST发送信息时，发送的信息写在send(写在这里)</h3>
<h3 id="setrequsetheaderheadervalue">setRequsetHeader(header，value)</h3>
<p>添加HTTP头<br>
header: 规定头的名称<br>
value： 规定头的值</p>
<h2 id="服务器响应">服务器响应</h2>
<h4 id="responsetext-获得字符串形式的响应数据">responseText 获得字符串形式的响应数据</h4>
<h4 id="responsexml-获得xml形式的响应数据">responseXML 获得XML形式的响应数据</h4>
<p>通常不是XML，就使用Text</p>
<pre><code class="language-javaScript">document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
</code></pre>
<p>如果是XML,则</p>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script&gt;
function loadXMLDoc()
{
  var xmlhttp;
  var txt,x,i;
  if (window.XMLHttpRequest)
  {
    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();
  }
  else
  {
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  xmlhttp.onreadystatechange=function()
  {
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
    {
      xmlDoc=xmlhttp.responseXML;
      txt=&quot;&quot;;
      x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);
      for (i=0;i&lt;x.length;i++)
      {
        txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;
      }
      document.getElementById(&quot;myDiv&quot;).innerHTML=txt;
    }
  }
  xmlhttp.open(&quot;GET&quot;,&quot;cd_catalog.xml&quot;,true);
  xmlhttp.send();
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;h2&gt;我收藏的 CD :&lt;/h2&gt;
&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;
&lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;获取我的 CD&lt;/button&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="onreadystatechange-事件-通常被绑定一个服务器响应函数">onreadystatechange 事件 通常被绑定一个服务器响应函数</h2>
<p>当open,send这些请求发送到服务器是，，服务器会返回响应<br>
onreadystatechange事件类似与onclick事件<br>
每当鼠标点击会触发onclick事件</p>
<h4 id="每当readystate改变时onreadystatechage会被触发一次">每当readyState改变时，onreadystatechage会被触发一次</h4>
<h3 id="readystate-存有xmlhttprequest的状态0-4之间变化">readyState  存有XMLHttpRequest的状态，0-4之间变化</h3>
<p>0：请求未初始化<br>
1：服务器连接已建立<br>
2：请求已接收<br>
3：请求处理中<br>
4：请求已完成，且响应已就绪</p>
<h3 id="status-存储状态">status 存储状态</h3>
<p>200：&quot;OK&quot;<br>
404: 未找到页面<br>
在onreadystatechange事件中，当readyState等于4且状态为200，表示响应就绪</p>
<pre><code class="language-javaScript">if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)     //当服务器响应成功
    {
        document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;   //前端要干的事
    }
</code></pre>
<h3 id="回调函数">回调函数</h3>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
var xmlhttp;
function loadXMLDoc(url,cfunc)
{
if (window.XMLHttpRequest)
  {// IE7+, Firefox, Chrome, Opera, Safari 代码
  xmlhttp=new XMLHttpRequest();
  }
else
  {// IE6, IE5 代码
  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
xmlhttp.onreadystatechange=cfunc;
xmlhttp.open(&quot;GET&quot;,url,true);
xmlhttp.send();
}
function myFunction()
{
	loadXMLDoc(&quot;/try/ajax/ajax_info.txt&quot;,function()             //调用上面的函数
	{
		if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
		{
			document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
		}
	});
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;使用 AJAX 修改文本内容&lt;/h2&gt;&lt;/div&gt;
&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;修改内容&lt;/button&gt;    //绑定自己调用的函数

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="与后台交互-documentgetelementbyidtxthintinnerhtmlxmlhttpresponsetext">与后台交互 document.getElementById(&quot;txtHint&quot;).innerHTML=xmlhttp.responseText;</h2>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script&gt;
function showCustomer(str)
{
  var xmlhttp;    
  if (str==&quot;&quot;)                 //开始状态，或者没有值
  {
    document.getElementById(&quot;txtHint&quot;).innerHTML=&quot;&quot;;
    return;               //直接结束
  }
  if (window.XMLHttpRequest)
  {
    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();            //创建一个XMLHttpRequest对象
  }
  else
  {
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/getcustomer.php?q=&quot;+str,true);   //通过GET方法向服务器请求（发送的信息就在url后面加上）这里是 &quot;...q=&quot; +str
  xmlhttp.send();
  xmlhttp.onreadystatechange=function()     //绑定服务器响应函数  ，根据readyState的变化，调用onreadystatechange
  {
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    //响应成功的标志
    {
      document.getElementById(&quot;txtHint&quot;).innerHTML=xmlhttp.responseText;    //从服务器得到数据
    }
  }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;form action=&quot;&quot;&gt; 
&lt;select name=&quot;customers&quot; onchange=&quot;showCustomer(this.value)&quot; style=&quot;font-family:Verdana, Arial, Helvetica, sans-serif;&quot;&gt;   //下拉列表
&lt;option value=&quot;APPLE&quot;&gt;Apple Computer, Inc.&lt;/option&gt;
&lt;option value=&quot;BAIDU &quot;&gt;BAIDU, Inc&lt;/option&gt;
&lt;option value=&quot;Canon&quot;&gt;Canon USA, Inc.&lt;/option&gt;
&lt;option value=&quot;Google&quot;&gt;Google, Inc.&lt;/option&gt;
&lt;option value=&quot;Nokia&quot;&gt;Nokia Corporation&lt;/option&gt;
&lt;option value=&quot;SONY&quot;&gt;Sony Corporation of America&lt;/option&gt;
&lt;/select&gt;
&lt;/form&gt;
&lt;br&gt;
&lt;div id=&quot;txtHint&quot;&gt;客户信息将显示在这...&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS实现完美的拖拽]]></title>
        <id>https://zhaojunjie-code.github.io/post/js-shi-xian-wan-mei-de-tuo-zhuai/</id>
        <link href="https://zhaojunjie-code.github.io/post/js-shi-xian-wan-mei-de-tuo-zhuai/">
        </link>
        <updated>2021-04-02T08:19:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="预备知识">预备知识</h1>
<p>##event事件对象</p>
<h3 id="与光标有关的属性-clientx">与光标有关的属性 clientX</h3>
<p>返回当事件被触发时，鼠标的水平坐标(距离 px)</p>
<h3 id="与光标有关的属性-clienty">与光标有关的属性 clientY</h3>
<p>返回当事件被触发时，鼠标的垂直坐标(距离 px)</p>
<h2 id="html元素对象">HTML元素对象</h2>
<h3 id="offsetleft">offsetLeft</h3>
<p>当前元素相对与最近定位的父元素的水平距离(px)</p>
<h3 id="offsettop">offsetTop</h3>
<p>当前元素相对与最近定位的父元素的垂直距离(px)</p>
<h1 id="跟随鼠标">跟随鼠标</h1>
<p>每当提到控制DOM跟随鼠标移动，我们头脑里会蹦出PageX,PageY 它们俩分别返回当前光标的水平坐标和垂直坐标。</p>
<pre><code class="language-javaScript">var left = event.pageX;
var top = event.pageY;
box1.style.left = left + &quot;px&quot;;
box1.style.top = top +&quot;px&quot;;
</code></pre>
<p>这很容易实现</p>
<h2 id="当我们将上述操作应用到拖拽操作时">当我们将上述操作应用到拖拽操作时</h2>
<p>我们会发现，点击一个元素的某一位置进行拖拽时，元素总会跳变到跟随鼠标移动的位置<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617353505592.png" alt="" loading="lazy"><br>
这导致用户体验感极差<br>
如何解决这个问题呢？<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617354112330.png" alt="" loading="lazy"><br>
我们可以看到</p>
<h3 id="clientx-offsetleft-水平跳变距离">clientX - offsetLeft = 水平跳变距离</h3>
<h3 id="同理-clienty-offsettop-垂直跳变距离">同理 clientY - offsetTop = 垂直跳变距离</h3>
<pre><code class="language-javaScript">box1.onmousedown = function (event) {
               var ol = event.clientX - box1.offsetLeft;
               var ot = event.clientY - box1.offsetTop;
               document.onmousemove = function (event) {
                   var X = event.pageX - ol;
                   var Y = event.pageY - ot;
                   box1.style.left = X + &quot;px&quot;;
                   box1.style.top = Y + &quot;px&quot;;
               }
           }
</code></pre>
<p>我们不希望看到跳变，那么就减去跳变距离</p>
]]></content>
    </entry>
</feed>