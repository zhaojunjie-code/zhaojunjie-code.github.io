<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhaojunjie-code.github.io/</id>
    <title>杰</title>
    <updated>2021-04-19T10:43:28.327Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhaojunjie-code.github.io/"/>
    <link rel="self" href="https://zhaojunjie-code.github.io/atom.xml"/>
    <subtitle>前端探索</subtitle>
    <logo>https://zhaojunjie-code.github.io/images/avatar.png</logo>
    <icon>https://zhaojunjie-code.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 杰</rights>
    <entry>
        <title type="html"><![CDATA[CSS-opacity不透明度]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-opacity-bu-tou-ming-du/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-opacity-bu-tou-ming-du/">
        </link>
        <updated>2021-04-19T07:32:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="opacity用于指定元素的不透明度00-10值越小越透明0表示完全透明1表示不透明">opacity用于指定元素的不透明度：0.0-1.0值越小，越透明.0表示完全透明，1表示不透明</h1>
<h2 id="可以应用在轮播图的切换效果中">可以应用在轮播图的切换效果中。</h2>
<h3 id="图片叠在一起设置计时器使上面一张图片的不透明度从1渐变到0下面的图片就显示出来了">图片叠在一起，设置计时器，使上面一张图片的不透明度从1渐变到0，下面的图片就显示出来了</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS-伪类]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-wei-lei/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-wei-lei/">
        </link>
        <updated>2021-04-19T06:27:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="伪类用于定义元素的特殊状态">伪类用于定义元素的特殊状态</h1>
<p>伪类语法</p>
<pre><code class="language-js">selector:pseudo-class {
    property:value;
}
</code></pre>
<h2 id="悬停ahover当鼠标停在a链接上a会出现的效果同理悬停在div上divhover">悬停：a:hover{}当鼠标停在a链接上，a会出现的效果；同理，悬停在div上div:hover{},</h2>
<h2 id="工具提示悬停鼠标停在div上显示p的效果">工具提示悬停：鼠标停在div上，显示p的效果</h2>
<pre><code class="language-js">p {
  display: none;
  background-color: yellow;
  padding: 20px;
}

div:hover p {
  display: block;
}
</code></pre>
<h1 id="first-child伪类与指定的元素匹配并规定该元素是另一个元素的第一个子元素">:first-child伪类：与指定的元素匹配，并规定：该元素是另一个元素的第一个子元素</h1>
<h1 id="注意处在-first-child-的前一个选择器是第一个子元素例如-ifirst-childi是第一个子元素p-ifirst-child在p中的第一个子元素i">注意：处在 :first-child 的前一个选择器，是第一个子元素；例如 i:first-child,i是第一个子元素；p i:first-child，在p中的第一个子元素i。</h1>
<h1 id="p-first-child-i这种写法第一个子元素是p要修饰的内容是p里面的i">p :first-child i,这种写法，第一个子元素是p，要修饰的内容是p里面的i</h1>
<p>三个例子</p>
<ol>
<li>匹配首个p元素</li>
</ol>
<pre><code class="language-js">p:first-child {
    color: blue;
}
</code></pre>
<ol start="2">
<li>匹配所有p元素的首个i元素</li>
</ol>
<pre><code class="language-js">p i:first-child {
    color:blue;
}
</code></pre>
<p>3.匹配所有首个p元素中的所有i元素</p>
<pre><code class="language-js">p :first-child i {
    color:blue;
}
</code></pre>
<h1 id="lang伪类允许您为不同的语言定义特殊的规则">:lang伪类：允许您为不同的语言定义特殊的规则。</h1>
<pre><code class="language-js">q:lang(en) {
  quotes: &quot;~&quot; &quot;~&quot;;
}
&lt;p&gt;Some text &lt;q lang=&quot;no&quot;&gt;A quote in a paragraph&lt;/q&gt; Some text.&lt;/p&gt;
</code></pre>
<p>效果：被q lang=&quot;no&quot;双标签包起来的元素：首尾加上了&quot;~&quot;号<br>
<img src="https://zhaojunjie-code.github.io//post-images/1618815815051.PNG" alt="" loading="lazy"></p>
<h1 id="focus伪类为input标签渲染获取焦点时的效果">:focus伪类：为input标签，渲染获取焦点时的效果</h1>
<pre><code class="language-js">input:focus{
    background-color:yellow;
}
</code></pre>
<p>效果：当鼠标点击input框时，input框背景颜色边黄</p>
<h1 id="xbefore伪类-为所有x标签的内容之前是一个块添加样式-用content添加文本">X::before伪类: 为所有X标签的内容之前（是一个块）添加样式 用content:&quot;&quot;;添加文本，</h1>
<pre><code class="language-js">p:before{
    content:&quot;台词：！&quot;:
}
&lt;p&gt;你这个叛徒&lt;/p&gt;
</code></pre>
<p>效果：p标签渲染后的效果 ”台词：！你这个叛徒“</p>
<h1 id="xfirst-letter伪类-首字母大写">X::first-letter伪类: 首字母大写</h1>
<pre><code class="language-js">p:first-letter{
    font-size:200%;
}
&lt;p&gt;hello&lt;/p&gt;
</code></pre>
<p>效果：Hello</p>
<h1 id="selection伪类用户选择时的效果用户在网页上用鼠标选择一段文本进行复制通常文本的背景颜色会变蓝">::selection伪类：用户选择时的效果；用户在网页上用鼠标选择一段文本进行复制，通常文本的背景颜色会变蓝</h1>
<pre><code class="language-js">::selection {
    bakground-color:blue;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zhaojunjie-code.github.io//post-images/1618816689269.PNG" alt="" loading="lazy"></figure>
<h1 id="伪元素伪元素用于设置元素指定部分的样式">伪元素：伪元素用于设置元素指定部分的样式。</h1>
<h1 id="注意双冒号">注意双冒号 ::</h1>
<h2 id="first-letter-伪元素用于向文本的首字母添加特殊样式">::first-letter 伪元素用于向文本的首字母添加特殊样式。</h2>
<h2 id="first-line-伪元素用于向文本的首行添加特殊样式">::first-line 伪元素用于向文本的首行添加特殊样式。</h2>
<h2 id="伪元素和-css-类">伪元素和 CSS 类</h2>
<pre><code class="language-js">.intro::first-letter {
  color: #ff0000;
  font-size: 200%;
}
</code></pre>
<p>效果:为class=&quot;intro&quot;的类，首字母大写并设置颜色#ff0000</p>
<h2 id="多个伪元素一个标签或一个类可以组合使用多个伪元素">多个伪元素：一个标签或一个类可以组合使用多个伪元素</h2>
<h2 id="before伪元素">::before伪元素</h2>
<p>content:;<br>
可以添加文本: &quot;用引号括起来可以在一个标签或者一个类之前添加文本&quot;<br>
可以添加图片:&quot;url(smiley.gif);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS组合器]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-xuan-ze-qi/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-xuan-ze-qi/">
        </link>
        <updated>2021-04-17T10:24:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="后代选择器-空格">后代选择器: 空格</h1>
<p>很简单，例如div p {？} ：这说明div下的所有p后代都需要有？这个效果</p>
<h1 id="子选择器">子选择器: &gt;</h1>
<p>div&gt;p{} 说明那些唯一爸爸是div的p才拥有效果，不能是爷爷，曾爷爷</p>
<h1 id="相邻兄弟选择器">相邻兄弟选择器: +</h1>
<p>div +p {}</p>
<pre><code class="language-js">&lt;div&gt;
  &lt;p&gt;div 中的段落 1。&lt;/p&gt;
  &lt;p&gt;div 中的段落 2。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;段落 3。不在 div 中。&lt;/p&gt;
</code></pre>
<p>p与div同级且相邻且p在div 后面出现</p>
<h1 id="通用兄弟选择器-~">通用兄弟选择器: ~</h1>
<p>div~p{}<br>
选中与div同级的p</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS定位机制]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-ding-wei-ji-zhi/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-ding-wei-ji-zhi/">
        </link>
        <updated>2021-04-17T09:16:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="css有三种定位机制-普通流浮动绝对定位">CSS有三种定位机制 普通流，浮动，绝对定位</h1>
<h2 id="普通流由html位置决定块级框一个接一个排列框之间的垂直距离是由框的垂直外边计算出来的行内框在一行中水平布置水平内边距-边框和外边距调整它们的间距垂直边距边框距不会改变其高度">普通流:由HTML位置决定，块级框一个接一个排列，框之间的垂直距离是由框的垂直外边计算出来的；行内框在一行中水平布置，水平内边距、边框和外边距调整它们的间距，垂直边距，边框距不会改变其高度。</h2>
<h2 id="定位-相对定位-relative">定位-相对定位 relative</h2>
<h3 id="positonrelative其元素并不会脱离文档流而是还出现在相对定位之前的位置但是可以通过topleftrightbottom设置其偏移距离注意它一直在文档流中仍然占据原来的空间-移动后会覆盖其他的框">positon:relative;其元素并不会脱离文档流，而是还出现在相对定位之前的位置，但是可以通过top,left,right,bottom设置其偏移距离，注意：它一直在文档流中，仍然占据原来的空间。移动后会覆盖其他的框</h3>
<figure data-type="image" tabindex="1"><img src="https://zhaojunjie-code.github.io//post-images/1618652538672.PNG" alt="" loading="lazy"></figure>
<h3 id="positonabsolute其元素会从文档流中删除完全脱离文档流并相对于一个已经定位的包含块定位如果没有包含块则相对于初始块定位元素原先在文档流中占据的空间会被浏览器关闭他之后的元素可能会上来补他的位置-元素定位后生成一个块级框而不论原来它在正常流中生成何种类型的框">positon:absolute;其元素会从文档流中删除(完全脱离文档流)，并相对于一个已经定位的包含块定位(如果没有包含块，则相对于初始块定位)，元素原先在文档流中占据的空间会被浏览器关闭，他之后的元素可能会上来补他的位置。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</h3>
<figure data-type="image" tabindex="2"><img src="https://zhaojunjie-code.github.io//post-images/1618652786818.PNG" alt="" loading="lazy"></figure>
<h2 id="浮动float-半脱离文档流">浮动float-半脱离文档流</h2>
<h3 id="半脱离文档流浮动的元素父元素不知道这算是脱离文档流但是与他一起脱离文档流的其他元素能看到他左浮动时依然在他的后面">半脱离文档流：浮动的元素，父元素不知道，这算是脱离文档流，但是与他一起脱离文档流的其他元素，能看到他，左浮动时，依然在他的后面。</h3>
<h3 id="常见的清除浮动和父元素跟随子元素撑开">常见的清除浮动和父元素跟随子元素撑开</h3>
<h4 id="清除浮动clearleftboth用于与浮动元素同级的元素在布局时不会跑到其下面而是重新占一行">清除浮动clear:left,both;用于与浮动元素同级的元素，在布局时，不会跑到其下面，而是重新占一行。</h4>
<h4 id="父元素终于认这个孩子了overflowhidden">父元素终于认这个孩子了：overflow:hidden;</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web前端方向]]></title>
        <id>https://zhaojunjie-code.github.io/post/web-qian-duan-fang-xiang/</id>
        <link href="https://zhaojunjie-code.github.io/post/web-qian-duan-fang-xiang/">
        </link>
        <updated>2021-04-16T00:41:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="就业">就业</h1>
<h2 id="一-春招时间3-4月">一、春招时间：3-4月</h2>
<h2 id="二-学习内容">二、学习内容</h2>
<ul>
<li>html/css</li>
<li><strong>JavaScript（ES5、ES6）</strong></li>
<li>框架（React或者Vue）</li>
<li>浏览器工作原理与实践</li>
<li>计算机网络（重点是HTTP、TCP）</li>
<li>数据结构与算法</li>
</ul>
<h2 id="三-简历准备">三、简历准备</h2>
<ul>
<li>博客
<ul>
<li>Typora</li>
<li>Markdown</li>
<li>Gridea</li>
</ul>
</li>
<li>项目
<ul>
<li>实训项目
<ul>
<li>node.js
<ul>
<li>链接：https://pan.baidu.com/s/1BHMKAQ_7sS8BnlOrcl8BUg<br>
提取码：ywva<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
</ul>
</li>
<li>比赛项目</li>
</ul>
</li>
</ul>
<h2 id="四-学习资料">四、学习资料</h2>
<ul>
<li>JavaScript
<ul>
<li>JavaScript高级程序设计（ES5）
<ul>
<li>音频教程：https://www.ximalaya.com/gerenchengzhang/3740790/</li>
</ul>
</li>
<li>ECMAScript 6入门
<ul>
<li>https://es6.ruanyifeng.com/#README</li>
</ul>
</li>
</ul>
</li>
<li>计算机网络
<ul>
<li>图解TCP/IP</li>
<li>图解HTTP</li>
<li>计算机网络自顶向下</li>
<li><strong>透视HTTP</strong>
<ul>
<li>链接：https://pan.baidu.com/s/1SI8bD0t9VI29qJgZdrcAug<br>
提取码：pe41<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
</ul>
</li>
<li>浏览器工作原理与实践
<ul>
<li>链接：https://pan.baidu.com/s/1gO05ERziH9r3aYoKuZA9sw<br>
提取码：8wqy<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
<li>数据结构与算法
<ul>
<li>Leetcode</li>
<li>牛客（剑指offer）</li>
</ul>
</li>
<li>搜索
<ul>
<li>掘金</li>
<li>思否</li>
<li>知乎</li>
<li>MDN</li>
</ul>
</li>
<li>面试
<ul>
<li>牛客</li>
<li>实习僧</li>
<li>拉钩</li>
<li>Boss直聘</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS中级总结]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-zhong-ji-zong-jie/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-zhong-ji-zong-jie/">
        </link>
        <updated>2021-04-12T12:39:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="display属性">display属性</h1>
<p>如何显示一个元素：block，inline<br>
首先要了解块级元素：占据一行的宽度<br>
div,h1-h6,p,form,header,footer,section</p>
<p>行内元素：占据所需的宽度<br>
span,a,img</p>
<h2 id="覆盖默认的display值">覆盖默认的display值</h2>
<p>li{display:inline;}  li本来是块级元素，强制将其转变为行内元素<br>
span{display:block;}span本来是行内元素，强制将其转变为块级元素<br>
注意这种强制转换为行内元素的标签，是不能为其设置高度的</p>
<h2 id="displaynone-通常与js用来隐藏显示元素-该元素的位置会被其他元素占据">display:none 通常与JS用来隐藏显示元素 该元素的位置会被其他元素占据</h2>
<pre><code class="language-javascript">document.getelementById(&quot;btn01).onclick = function(){  //为按钮绑定单击响应函数
      document.getelementById(&quot;box01).style.display = &quot;none&quot;;
}
</code></pre>
<h2 id="visibilityhidden指定元素是否可见元素所占据的位置还是存在">visibility：hidden指定元素是否可见，元素所占据的位置还是存在</h2>
<h1 id="position定位">position定位</h1>
<h2 id="static浏览器为其自动安排位置">static:浏览器为其自动安排位置</h2>
<h2 id="relative元素相对于其正常位置进行定位这时要用上lefttopbottom">relative:元素相对于其正常位置进行定位；这时要用上left:;top:;bottom:;</h2>
<h2 id="fixed相对于屏幕定位鼠标滚动页面它始终处于同一位置">fixed:相对于屏幕定位，鼠标滚动页面，它始终处于同一位置</h2>
<h2 id="absolute相对于最近的定位了的祖先元素进行定位-如果没有祖先则使用文档主体并随页面滚动">absolute：相对于最近的定位了的祖先元素进行定位。如果没有祖先，则使用文档主体，并随页面滚动。</h2>
<p>&quot;定位了的祖先&quot;:除了static属性以外的其他属性fixed,relative...都可以被定义为&quot;定位了的祖先&quot;</p>
<h2 id="fixed粘性定位-粘性定位开始并不是粘性定位而是relative直到至少给定一个topleft来指明什么时侯开始成为粘性定位">fixed:粘性定位。粘性定位开始并不是粘性定位，而是relative；直到至少给定一个top,left,...来指明什么时侯开始成为粘性定位。</h2>
<h2 id="z-index重叠定位">z-index重叠定位</h2>
<p>用来确定重叠的元素，呈现给用户的顺序。<br>
z-index=-1 堆叠顺序较低，所以成为了背景板<br>
z-index越高，则越是主角</p>
<h1 id="overflow-溢出指在内容太大而无法放在指定区域用来决定是裁剪还是添加滚动条">overflow 溢出：指在内容太大而无法放在指定区域，用来决定是裁剪还是添加滚动条</h1>
<h2 id="visible默认溢出就溢出在外面接着渲染">visible:默认，溢出就溢出，在外面接着渲染</h2>
<h2 id="hidden裁剪溢出部分不要了">hidden:裁剪，溢出部分不要了</h2>
<h2 id="scroll加滚动条">scroll:加滚动条</h2>
<h1 id="float浮动">float浮动</h1>
<h2 id="inherit继承父级float值">inherit继承父级float值</h2>
<h1 id="clear清除">clear清除</h1>
<p>##none：允许两侧都有浮动元素   会出现不浮动元素嵌入到浮动元素下面</p>
<h2 id="left左侧不允许浮动元素左侧被管制-如果">left：左侧不允许浮动元素，左侧被管制   如果</h2>
<h2 id="right同上">right：同上</h2>
<h2 id="both左侧或右侧不允许浮动元素">both：左侧或右侧不允许浮动元素</h2>
<h2 id="inherit继承父级的clear">inherit：继承父级的clear</h2>
<h2 id="清除原理-一个div1左浮动另一个div2不浮动则会出现给用户这样的情况div2出现在div1的下面当div2使用clearleft时浏览器检查div2发现其左侧有div1在浮动他会清除这种效果本来div1是左漂浮起来了div2在其下面浏览器将div1的投影也占位div2自然而然就跑到了div1的一下一行注意float与clear是对应的div1-floatleft-那么div2-clearleft这样才会起作用">清除原理： 一个div1左浮动，另一个div2不浮动；则会出现给用户这样的情况，div2出现在div1的下面，当div2使用clear:left;时，浏览器检查div2，发现其左侧有div1在浮动，他会清除这种效果(本来div1是左漂浮起来了，div2在其下面，浏览器将div1的投影也占位，div2自然而然就跑到了div1的一下一行)注意float与clear是对应的div1 float:left 那么div2 clear:left这样才会起作用</h2>
<h1 id="box-sizingborder-box-强制限制内边距和边框的厚度不能撑开盒子除非内边距和边框厚度设置的太离谱为了保证内容盒子会被放大">box-sizing:border-box; 强制限制内边距和边框的厚度不能撑开盒子(除非内边距和边框厚度设置的太离谱，为了保证内容，盒子会被放大)</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS基础总结]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-zong-jie/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-zong-jie/">
        </link>
        <updated>2021-04-12T06:06:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="background">background</h1>
<h2 id="background-image-背景图">background-image 背景图</h2>
<p>默认情况下background-image属性在水平和垂直方向上都重复的图像</p>
<h2 id="background-repeat-设置重复方向">background-repeat  设置重复方向</h2>
<p>repeatx:水平方向重复<br>
repeaty:垂直方向上重复<br>
no-repeat:不重复</p>
<h2 id="background-position-设置图片位置">background-position  设置图片位置</h2>
<p>right top :右上角</p>
<h2 id="background-attachment-设置图片附着">background-attachment 设置图片附着</h2>
<p>fixed:一直附着在网页上，随着鼠标滚动 client右上角<br>
scroll:不随鼠标滚动，定死在右上角<br>
简写</p>
<pre><code class="language-css">body {
background: #ffffff url(&quot;tree.png&quot;) no-repeat right top;  //注意顺序 颜色，背景图，重复，位置
}
</code></pre>
<h1 id="border">border</h1>
<h2 id="border-style-设置边框的类型">border-style 设置边框的类型</h2>
<p>dotted - 定义点线边框<br>
*dashed - 定义虚线边框<br>
*solid - 定义实线边框<br>
double - 定义双边框<br>
groove - 定义 3D 坡口边框。效果取决于 border-color 值<br>
ridge - 定义 3D 脊线边框。效果取决于 border-color 值<br>
inset - 定义 3D inset 边框。效果取决于 border-color 值<br>
outset - 定义 3D outset 边框。效果取决于 border-color 值<br>
none - 定义无边框<br>
hidden - 定义隐藏边框</p>
<h2 id="border-width-边框宽度">border-width 边框宽度</h2>
<p>medium,thick,<br>
还可设置四个值(上右下左)，可以设置个边的长度</p>
<h2 id="border-color-边框颜色">border-color 边框颜色</h2>
<p>同上</p>
<h2 id="border-radius-添加圆角">border-radius 添加圆角</h2>
<p>radius越大，左右边框越圆</p>
<h1 id="margin-外边距">margin 外边距</h1>
<h2 id="toprightbottomleft">top;right,bottom,left</h2>
<p>auto - 浏览器来计算外边距<br>
length - 以 px、pt、cm 等单位指定外边距<br>
% - 指定以包含元素宽度的百分比计的外边距<br>
inherit - 指定应从父元素继承外边距</p>
<h2 id="margin简写">margin简写</h2>
<p>四个值：上，右，下，左<br>
三个值：上，右左，下<br>
两个值：上下，左右<br>
一个值：上右下左<br>
auto:元素在其容器中水平居中，该元素占据指定宽度，并且甚于空间将在左右边界之间平均分配<br>
inherit:</p>
<pre><code class="language-css">div {
  border: 1px solid red;
  margin-left: 100px;
}
p.ex1 {
  margin-left: inherit;      //class=ex1的元素，继承父元素div的外边距，也为margin-left: 100px;
}
</code></pre>
<h2 id="外边距合并">外边距合并</h2>
<h3 id="垂直外边距当两个垂直外边距相遇他们会合并成一个外边距">垂直外边距：当两个垂直外边距相遇，他们会合并成一个外边距</h3>
<p><img src="https://zhaojunjie-code.github.io//post-images/1618209661668.PNG" alt="" loading="lazy"><br>
解释一下：程序员的疏忽，给上面一个盒子设置了下边距，又给下面一个盒子设置了上边距；边距相包含，则浏览器会找出两个边距较大的作为包含后的边距</p>
<h3 id="嵌套外边距合并当两个盒子嵌套在一起父元素没有设置上内边距及边框则父元素的上外边距会与子元素的上外边距合并取较大者">嵌套外边距合并：当两个盒子嵌套在一起，父元素没有设置上内边距及边框，则父元素的上外边距会与子元素的上外边距合并，取较大者</h3>
<figure data-type="image" tabindex="1"><img src="https://zhaojunjie-code.github.io//post-images/1618210496706.PNG" alt="" loading="lazy"></figure>
<h3 id="甚至有空元素设置了上外边距和下外边距上下会合并取较大者">甚至有空元素，设置了上外边距和下外边距，上下会合并，取较大者</h3>
<h3 id="解决方案">解决方案：</h3>
<p>父元素加上 overflow:hidden的解除坍塌功能;<br>
父元素加上边框 border:1px solid transparent设边框加透明，不推荐；<br>
父元素或子元素 浮动或者定位</p>
<h1 id="padding-内边距">padding 内边距</h1>
<p>top,right,bottom,left<br>
length - 以 px、pt、cm 等单位指定内边距<br>
% - 指定以包含元素宽度的百分比计的内边距<br>
inherit - 指定应从父元素继承内边距<br>
基本操作根外边距一样：四个值，三个值，两个值，一个值</p>
<h2 id="padding可以撑大定义的width">padding可以撑大定义的width</h2>
<p>解决方案：box-sizing:border-box；width固定，不允许撑大width</p>
<h1 id="widthheight宽度高度不包括内边距外边距和边框">width,height宽度，高度：不包括内边距，外边距，和边框。</h1>
<p>auto - 默认。浏览器计算高度和宽度。<br>
length - 以 px、cm 等定义高度/宽度。<br>
% - 以包含块的百分比定义高度/宽度。<br>
initial - 将高度/宽度设置为默认值。<br>
inherit - 从其父值继承高度/宽度。</p>
<h2 id="max-width-设置最大宽度">max-width 设置最大宽度</h2>
<p>他的用处是：动态的宽度，随着浏览器窗口大小分配到宽度，但最大不呢个超过max-width</p>
<h1 id="框模型">框模型</h1>
<figure data-type="image" tabindex="2"><img src="https://zhaojunjie-code.github.io//post-images/1618212892530.PNG" alt="" loading="lazy"></figure>
<h1 id="轮廓outline边框之外加一些渲染">轮廓outline：边框之外加一些渲染</h1>
<p>outline-style<br>
outline-color<br>
outline-width 轮廓宽度<br>
outline-offset 轮廓与边框的距离<br>
outline</p>
<pre><code class="language-css"> outline: 1px solid red;
</code></pre>
<h1 id="文本">文本</h1>
<h2 id="color-background-color">color background-color</h2>
<p>字体颜色和背景颜色</p>
<h2 id="text-align-文本对齐">text-align 文本对齐</h2>
<p>center:居中<br>
left:左<br>
right:右<br>
justify:使一段文章的每一行宽度都相等，浏览器会自动的为，不能成为一行的添加空格，凑成一行下图，注意到浏览器自动添加空格，使每一行宽度都一样<br>
<img src="https://zhaojunjie-code.github.io//post-images/1618225316912.PNG" alt="" loading="lazy"></p>
<h2 id="direction文本方向">direction文本方向</h2>
<p>ltr:left to right    默认方向：从左向右  左对齐<br>
rtl:right to left  自定义方向：从左向右 右对齐<br>
inherit：继承父元素的方向</p>
<h2 id="unicode-bidi-用于同一个页面里存在从不同方向读进的文本显示与direction同时使用确定文本方向">unicode-bidi: 用于同一个页面里存在从不同方向读进的文本显示,与direction同时使用，确定文本方向</h2>
<p>有以下的取值<br>
normal:同原来的方向一样<br>
bidi-override:按照direction的值，排序如果是左对齐，就正着来，右对齐就从反着写。<br>
embed:作用于行内元素，按照direction的值决定插入在哪里，正着写</p>
<h2 id="vertical-align-垂直对齐">vertical-align 垂直对齐</h2>
<p>top: 文本顶部对齐<br>
middle:文本中间对齐<br>
bottom:文本底部对齐<br>
<img src="https://zhaojunjie-code.github.io//post-images/1618227261063.PNG" alt="" loading="lazy"><br>
#text-decoration 文本装饰<br>
none:用于从链接上删除下划线<br>
line-through:删除线</p>
<h2 id="text-transform文本转换">text-transform文本转换</h2>
<p>uppercase:大写<br>
lowercase:小写<br>
capitalize:开头字母大写</p>
<h1 id="文字间距">文字间距</h1>
<h2 id="text-indent文字缩进">text-indent文字缩进</h2>
<p>第一行的缩进，写文章时空两个</p>
<h2 id="letter-spacing-字母间距">letter-spacing 字母间距</h2>
<p>指定文本中字符之间的间距<br>
3px:字母与字母之间有3像素的距离<br>
-3px:字母于字母之间缩进3像素的距离</p>
<h2 id="white-space-空白">white-space 空白</h2>
<p>nowrap:禁用元素内文本的换行<br>
#text-shadow 文本阴影<br>
水平阴影，垂直阴影 单位px<br>
#font-size 字体大小<br>
注意的一点就是：1px = 16em<br>
font简写<br>
注意<br>
size和family是必要的，还有style斜体italic；width粗细700</p>
<h1 id="a链接">a链接</h1>
<p>a.link:未访问的链接<br>
a.visited：访问过的链接<br>
a.hover:鼠标放上去时<br>
a.active:链接被点击时</p>
<h1 id="列表">列表</h1>
<p>注意一点<br>
list-style:none;之后，列表依然有边距，可以用margin:0;padding:0;删除边距</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-数据、方法、数据绑定]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/">
        </link>
        <updated>2021-04-07T12:51:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据">数据</h1>
<pre><code class="language-javascript">var data = { a: 1 }
var vm = new Vue({
 data: data
})
vm.$data === data // -&gt; true
vm.a === data.a // -&gt; true
// 设置属性也会影响到原始数据
vm.a = 2
data.a // -&gt; 2
// 反之亦然
data.a = 3
vm.a // -&gt; 3
</code></pre>
<p>如上，当在模板中使用{{a}},也会得到vm.a，修改vm.a，模板中的{{a}},也会改变，这称为</p>
<h3 id="响应式数据">响应式数据</h3>
<p>只有在初始化后的数据，才是响应式的，初始化后，再加入vm.b，这样不会有响应</p>
<h1 id="方法">方法</h1>
<h2 id="通过选择属性methods定义方法并通过v-on指令监听dom事件">通过选择属性methods:{},定义方法，并通过v-on指令监听DOM事件</h2>
<pre><code class="language-javascript">&lt;button v-on:click=&quot;alert&quot;/&gt;alert&lt;button&gt;
new Vue({
el : '#app',
data : { a : 1},
methods : {
　　 alert : function() {
　　　 alert(this.a);
　　 }
}
});
</code></pre>
<h1 id="数据绑定">数据绑定</h1>
<p>1.文本插值<br>
{{文本插值}}<br>
2.HTML属性</p>
<pre><code class="language-javascript">&lt;div id=&quot;id-{{id}}&quot;&gt;&lt;/div&gt; // &lt;div id=&quot;id-1&quot;&gt;&lt;/div&gt;
</code></pre>
<p>3.绑定表达式</p>
<pre><code class="language-javascript">{{ index + 1 }} // 1
{{ index == 0 ? 'a' : 'b'}} // a
{{ name.split('').join('|') }} // V|u|e
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-模板]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/">
        </link>
        <updated>2021-04-07T12:23:59.000Z</updated>
        <content type="html"><![CDATA[<p>Vue.js的使用都是通过构造函数Vue({option})，创建一个Vue实例：</p>
<pre><code class="language-javascript">var vm = new Vue({
    el:                           //挂载html元素，准备操作它
    template:
})
</code></pre>
<h2 id="el-用来为实例提供挂载元素">el 用来为实例提供挂载元素</h2>
<pre><code>el:'#app'
</code></pre>
<h2 id="默认将template值它的值一般都是html语句替换挂载元素即el对应的元素">默认将template值，(它的值一般都是html语句)替换挂载元素，即(el)对应的元素</h2>
<h3 id="class合并挂载元素和模板根节点的属性-id则以模板根节点为属性">(class)合并挂载元素和模板根节点的属性, (id)则以模板根节点为属性</h3>
<p>因为要在为template赋html语句。这样影响可读性<br>
一般</p>
<pre><code class="language-javascript">&lt;div id=&quot;app&quot;&gt;
&lt;p&gt;123&lt;/p&gt;
&lt;/div&gt;
&lt;script id=&quot;tpl&quot; type=&quot;x-template&quot;&gt;           //script1
&lt;div&gt;
　　 &lt;p&gt;This is a tpl from script tag&lt;/p&gt;
&lt;/div&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;                  //script2
var vm = new Vue({
　　 el : '#app',
　　 template : '#tpl'                    //取自于script1
});
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue组件]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-zu-jian/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-zu-jian/">
        </link>
        <updated>2021-04-07T04:11:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="组件是一个拥有预定义选项的一个vue实例">组件是一个拥有预定义选项的一个Vue实例</h1>
<p>定义语句<br>
Vue.component(&quot;组件的名字(字符串),以对象的形式描述一个组件)</p>
<pre><code class="language-javaScript">&lt;html&gt;
&lt;body&gt;
    &lt;div id=&quot;app9&quot;&gt;
        &lt;button-counter&gt;&lt;/button-counter&gt;          &lt;!--组件标签--&gt;
    &lt;/div&gt;
&lt;\body&gt;
&lt;\html&gt;
&lt;script&gt;
        Vue.component('button-counter', {             //Vue组件
            data: function () {   //on:click响应函数
                return {
                    count: 0     //初始化默认
                }
            },
            template: &quot;&lt;button v-on:click='count++'&gt;你点击了{{count}}次&lt;/button&gt;&quot;    //模板,使组件标签拥有模板的作用，我们看到模板是一个button标签，里面自带Vue的v-on绑定函数，让count++，函数在上面的DATA域
        })
        var app9 = new Vue({              //创建Vue对象
            el: &quot;#app9&quot;,                          //元素截获
            data: {                                     //数据对象

            }
        });
&lt;\script&gt;       
</code></pre>
]]></content>
    </entry>
</feed>