<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhaojunjie-code.github.io/</id>
    <title>杰</title>
    <updated>2021-04-16T00:42:29.828Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhaojunjie-code.github.io/"/>
    <link rel="self" href="https://zhaojunjie-code.github.io/atom.xml"/>
    <subtitle>前端探索</subtitle>
    <logo>https://zhaojunjie-code.github.io/images/avatar.png</logo>
    <icon>https://zhaojunjie-code.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 杰</rights>
    <entry>
        <title type="html"><![CDATA[Web前端方向]]></title>
        <id>https://zhaojunjie-code.github.io/post/web-qian-duan-fang-xiang/</id>
        <link href="https://zhaojunjie-code.github.io/post/web-qian-duan-fang-xiang/">
        </link>
        <updated>2021-04-16T00:41:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="就业">就业</h1>
<h2 id="一-春招时间3-4月">一、春招时间：3-4月</h2>
<h2 id="二-学习内容">二、学习内容</h2>
<ul>
<li>html/css</li>
<li><strong>JavaScript（ES5、ES6）</strong></li>
<li>框架（React或者Vue）</li>
<li>浏览器工作原理与实践</li>
<li>计算机网络（重点是HTTP、TCP）</li>
<li>数据结构与算法</li>
</ul>
<h2 id="三-简历准备">三、简历准备</h2>
<ul>
<li>博客
<ul>
<li>Typora</li>
<li>Markdown</li>
<li>Gridea</li>
</ul>
</li>
<li>项目
<ul>
<li>实训项目
<ul>
<li>node.js
<ul>
<li>链接：https://pan.baidu.com/s/1BHMKAQ_7sS8BnlOrcl8BUg<br>
提取码：ywva<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
</ul>
</li>
<li>比赛项目</li>
</ul>
</li>
</ul>
<h2 id="四-学习资料">四、学习资料</h2>
<ul>
<li>JavaScript
<ul>
<li>JavaScript高级程序设计（ES5）
<ul>
<li>音频教程：https://www.ximalaya.com/gerenchengzhang/3740790/</li>
</ul>
</li>
<li>ECMAScript 6入门
<ul>
<li>https://es6.ruanyifeng.com/#README</li>
</ul>
</li>
</ul>
</li>
<li>计算机网络
<ul>
<li>图解TCP/IP</li>
<li>图解HTTP</li>
<li>计算机网络自顶向下</li>
<li><strong>透视HTTP</strong>
<ul>
<li>链接：https://pan.baidu.com/s/1SI8bD0t9VI29qJgZdrcAug<br>
提取码：pe41<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
</ul>
</li>
<li>浏览器工作原理与实践
<ul>
<li>链接：https://pan.baidu.com/s/1gO05ERziH9r3aYoKuZA9sw<br>
提取码：8wqy<br>
复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享</li>
</ul>
</li>
<li>数据结构与算法
<ul>
<li>Leetcode</li>
<li>牛客（剑指offer）</li>
</ul>
</li>
<li>搜索
<ul>
<li>掘金</li>
<li>思否</li>
<li>知乎</li>
<li>MDN</li>
</ul>
</li>
<li>面试
<ul>
<li>牛客</li>
<li>实习僧</li>
<li>拉钩</li>
<li>Boss直聘</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS基础总结]]></title>
        <id>https://zhaojunjie-code.github.io/post/css-zong-jie/</id>
        <link href="https://zhaojunjie-code.github.io/post/css-zong-jie/">
        </link>
        <updated>2021-04-12T06:06:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="background">background</h1>
<h2 id="background-image-背景图">background-image 背景图</h2>
<p>默认情况下background-image属性在水平和垂直方向上都重复的图像</p>
<h2 id="background-repeat-设置重复方向">background-repeat  设置重复方向</h2>
<p>repeatx:水平方向重复<br>
repeaty:垂直方向上重复<br>
no-repeat:不重复</p>
<h2 id="background-position-设置图片位置">background-position  设置图片位置</h2>
<p>right top :右上角</p>
<h2 id="background-attachment-设置图片附着">background-attachment 设置图片附着</h2>
<p>fixed:一直附着在网页上，随着鼠标滚动 client右上角<br>
scroll:不随鼠标滚动，定死在右上角<br>
简写</p>
<pre><code class="language-css">body {
background: #ffffff url(&quot;tree.png&quot;) no-repeat right top;  //注意顺序 颜色，背景图，重复，位置
}
</code></pre>
<h1 id="border">border</h1>
<h2 id="border-style-设置边框的类型">border-style 设置边框的类型</h2>
<p>dotted - 定义点线边框<br>
*dashed - 定义虚线边框<br>
*solid - 定义实线边框<br>
double - 定义双边框<br>
groove - 定义 3D 坡口边框。效果取决于 border-color 值<br>
ridge - 定义 3D 脊线边框。效果取决于 border-color 值<br>
inset - 定义 3D inset 边框。效果取决于 border-color 值<br>
outset - 定义 3D outset 边框。效果取决于 border-color 值<br>
none - 定义无边框<br>
hidden - 定义隐藏边框</p>
<h2 id="border-width-边框宽度">border-width 边框宽度</h2>
<p>medium,thick,<br>
还可设置四个值(上右下左)，可以设置个边的长度</p>
<h2 id="border-color-边框颜色">border-color 边框颜色</h2>
<p>同上</p>
<h2 id="border-radius-添加圆角">border-radius 添加圆角</h2>
<p>radius越大，左右边框越圆</p>
<h1 id="margin-外边距">margin 外边距</h1>
<h2 id="toprightbottomleft">top;right,bottom,left</h2>
<p>auto - 浏览器来计算外边距<br>
length - 以 px、pt、cm 等单位指定外边距<br>
% - 指定以包含元素宽度的百分比计的外边距<br>
inherit - 指定应从父元素继承外边距</p>
<h2 id="margin简写">margin简写</h2>
<p>四个值：上，右，下，左<br>
三个值：上，右左，下<br>
两个值：上下，左右<br>
一个值：上右下左<br>
auto:元素在其容器中水平居中，该元素占据指定宽度，并且甚于空间将在左右边界之间平均分配<br>
inherit:</p>
<pre><code class="language-css">div {
  border: 1px solid red;
  margin-left: 100px;
}
p.ex1 {
  margin-left: inherit;      //class=ex1的元素，继承父元素div的外边距，也为margin-left: 100px;
}
</code></pre>
<h2 id="外边距合并">外边距合并</h2>
<h3 id="垂直外边距当两个垂直外边距相遇他们会合并成一个外边距">垂直外边距：当两个垂直外边距相遇，他们会合并成一个外边距</h3>
<p><img src="https://zhaojunjie-code.github.io//post-images/1618209661668.PNG" alt="" loading="lazy"><br>
解释一下：程序员的疏忽，给上面一个盒子设置了下边距，又给下面一个盒子设置了上边距；边距相包含，则浏览器会找出两个边距较大的作为包含后的边距</p>
<h3 id="嵌套外边距合并当两个盒子嵌套在一起父元素没有设置上内边距及边框则父元素的上外边距会与子元素的上外边距合并取较大者">嵌套外边距合并：当两个盒子嵌套在一起，父元素没有设置上内边距及边框，则父元素的上外边距会与子元素的上外边距合并，取较大者</h3>
<figure data-type="image" tabindex="1"><img src="https://zhaojunjie-code.github.io//post-images/1618210496706.PNG" alt="" loading="lazy"></figure>
<h3 id="甚至有空元素设置了上外边距和下外边距上下会合并取较大者">甚至有空元素，设置了上外边距和下外边距，上下会合并，取较大者</h3>
<h3 id="解决方案">解决方案：</h3>
<p>父元素加上 overflow:hidden的解除坍塌功能;<br>
父元素加上边框 border:1px solid transparent设边框加透明，不推荐；<br>
父元素或子元素 浮动或者定位</p>
<h1 id="padding-内边距">padding 内边距</h1>
<p>top,right,bottom,left<br>
length - 以 px、pt、cm 等单位指定内边距<br>
% - 指定以包含元素宽度的百分比计的内边距<br>
inherit - 指定应从父元素继承内边距<br>
基本操作根外边距一样：四个值，三个值，两个值，一个值</p>
<h2 id="padding可以撑大定义的width">padding可以撑大定义的width</h2>
<p>解决方案：box-sizing:border-box；width固定，不允许撑大width</p>
<h1 id="widthheight宽度高度不包括内边距外边距和边框">width,height宽度，高度：不包括内边距，外边距，和边框。</h1>
<p>auto - 默认。浏览器计算高度和宽度。<br>
length - 以 px、cm 等定义高度/宽度。<br>
% - 以包含块的百分比定义高度/宽度。<br>
initial - 将高度/宽度设置为默认值。<br>
inherit - 从其父值继承高度/宽度。</p>
<h2 id="max-width-设置最大宽度">max-width 设置最大宽度</h2>
<p>他的用处是：动态的宽度，随着浏览器窗口大小分配到宽度，但最大不呢个超过max-width</p>
<h1 id="框模型">框模型</h1>
<figure data-type="image" tabindex="2"><img src="https://zhaojunjie-code.github.io//post-images/1618212892530.PNG" alt="" loading="lazy"></figure>
<h1 id="轮廓outline边框之外加一些渲染">轮廓outline：边框之外加一些渲染</h1>
<p>outline-style<br>
outline-color<br>
outline-width 轮廓宽度<br>
outline-offset 轮廓与边框的距离<br>
outline</p>
<pre><code class="language-css"> outline: 1px solid red;
</code></pre>
<h1 id="文本">文本</h1>
<h2 id="color-background-color">color background-color</h2>
<p>字体颜色和背景颜色</p>
<h2 id="text-align-文本对齐">text-align 文本对齐</h2>
<p>center:居中<br>
left:左<br>
right:右<br>
justify:使一段文章的每一行宽度都相等，浏览器会自动的为，不能成为一行的添加空格，凑成一行下图，注意到浏览器自动添加空格，使每一行宽度都一样<br>
<img src="https://zhaojunjie-code.github.io//post-images/1618225316912.PNG" alt="" loading="lazy"></p>
<h2 id="direction文本方向">direction文本方向</h2>
<p>ltr:left to right    默认方向：从左向右  左对齐<br>
rtl:right to left  自定义方向：从左向右 右对齐<br>
inherit：继承父元素的方向</p>
<h2 id="unicode-bidi-用于同一个页面里存在从不同方向读进的文本显示与direction同时使用确定文本方向">unicode-bidi: 用于同一个页面里存在从不同方向读进的文本显示,与direction同时使用，确定文本方向</h2>
<p>有以下的取值<br>
normal:同原来的方向一样<br>
bidi-override:按照direction的值，排序如果是左对齐，就正着来，右对齐就从反着写。<br>
embed:作用于行内元素，按照direction的值决定插入在哪里，正着写</p>
<h2 id="vertical-align-垂直对齐">vertical-align 垂直对齐</h2>
<p>top: 文本顶部对齐<br>
middle:文本中间对齐<br>
bottom:文本底部对齐<br>
<img src="https://zhaojunjie-code.github.io//post-images/1618227261063.PNG" alt="" loading="lazy"><br>
#text-decoration 文本装饰<br>
none:用于从链接上删除下划线<br>
line-through:删除线</p>
<h2 id="text-transform文本转换">text-transform文本转换</h2>
<p>uppercase:大写<br>
lowercase:小写<br>
capitalize:开头字母大写</p>
<h1 id="文字间距">文字间距</h1>
<h2 id="text-indent文字缩进">text-indent文字缩进</h2>
<p>第一行的缩进，写文章时空两个</p>
<h2 id="letter-spacing-字母间距">letter-spacing 字母间距</h2>
<p>指定文本中字符之间的间距<br>
3px:字母与字母之间有3像素的距离<br>
-3px:字母于字母之间缩进3像素的距离</p>
<h2 id="white-space-空白">white-space 空白</h2>
<p>nowrap:禁用元素内文本的换行<br>
#text-shadow 文本阴影<br>
水平阴影，垂直阴影 单位px<br>
#font-size 字体大小<br>
注意的一点就是：1px = 16em<br>
font简写<br>
注意<br>
size和family是必要的，还有style斜体italic；width粗细700</p>
<h1 id="a链接">a链接</h1>
<p>a.link:未访问的链接<br>
a.visited：访问过的链接<br>
a.hover:鼠标放上去时<br>
a.active:链接被点击时</p>
<h1 id="列表">列表</h1>
<p>注意一点<br>
list-style:none;之后，列表依然有边距，可以用margin:0;padding:0;删除边距</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-数据、方法、数据绑定]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-shu-ju-fang-fa-shu-ju-bang-ding/">
        </link>
        <updated>2021-04-07T12:51:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据">数据</h1>
<pre><code class="language-javascript">var data = { a: 1 }
var vm = new Vue({
 data: data
})
vm.$data === data // -&gt; true
vm.a === data.a // -&gt; true
// 设置属性也会影响到原始数据
vm.a = 2
data.a // -&gt; 2
// 反之亦然
data.a = 3
vm.a // -&gt; 3
</code></pre>
<p>如上，当在模板中使用{{a}},也会得到vm.a，修改vm.a，模板中的{{a}},也会改变，这称为</p>
<h3 id="响应式数据">响应式数据</h3>
<p>只有在初始化后的数据，才是响应式的，初始化后，再加入vm.b，这样不会有响应</p>
<h1 id="方法">方法</h1>
<h2 id="通过选择属性methods定义方法并通过v-on指令监听dom事件">通过选择属性methods:{},定义方法，并通过v-on指令监听DOM事件</h2>
<pre><code class="language-javascript">&lt;button v-on:click=&quot;alert&quot;/&gt;alert&lt;button&gt;
new Vue({
el : '#app',
data : { a : 1},
methods : {
　　 alert : function() {
　　　 alert(this.a);
　　 }
}
});
</code></pre>
<h1 id="数据绑定">数据绑定</h1>
<p>1.文本插值<br>
{{文本插值}}<br>
2.HTML属性</p>
<pre><code class="language-javascript">&lt;div id=&quot;id-{{id}}&quot;&gt;&lt;/div&gt; // &lt;div id=&quot;id-1&quot;&gt;&lt;/div&gt;
</code></pre>
<p>3.绑定表达式</p>
<pre><code class="language-javascript">{{ index + 1 }} // 1
{{ index == 0 ? 'a' : 'b'}} // a
{{ name.split('').join('|') }} // V|u|e
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue基础特性-模板]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-ji-chu-te-xing-mo-ban/">
        </link>
        <updated>2021-04-07T12:23:59.000Z</updated>
        <content type="html"><![CDATA[<p>Vue.js的使用都是通过构造函数Vue({option})，创建一个Vue实例：</p>
<pre><code class="language-javascript">var vm = new Vue({
    el:                           //挂载html元素，准备操作它
    template:
})
</code></pre>
<h2 id="el-用来为实例提供挂载元素">el 用来为实例提供挂载元素</h2>
<pre><code>el:'#app'
</code></pre>
<h2 id="默认将template值它的值一般都是html语句替换挂载元素即el对应的元素">默认将template值，(它的值一般都是html语句)替换挂载元素，即(el)对应的元素</h2>
<h3 id="class合并挂载元素和模板根节点的属性-id则以模板根节点为属性">(class)合并挂载元素和模板根节点的属性, (id)则以模板根节点为属性</h3>
<p>因为要在为template赋html语句。这样影响可读性<br>
一般</p>
<pre><code class="language-javascript">&lt;div id=&quot;app&quot;&gt;
&lt;p&gt;123&lt;/p&gt;
&lt;/div&gt;
&lt;script id=&quot;tpl&quot; type=&quot;x-template&quot;&gt;           //script1
&lt;div&gt;
　　 &lt;p&gt;This is a tpl from script tag&lt;/p&gt;
&lt;/div&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;                  //script2
var vm = new Vue({
　　 el : '#app',
　　 template : '#tpl'                    //取自于script1
});
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue组件]]></title>
        <id>https://zhaojunjie-code.github.io/post/vue-zu-jian/</id>
        <link href="https://zhaojunjie-code.github.io/post/vue-zu-jian/">
        </link>
        <updated>2021-04-07T04:11:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="组件是一个拥有预定义选项的一个vue实例">组件是一个拥有预定义选项的一个Vue实例</h1>
<p>定义语句<br>
Vue.component(&quot;组件的名字(字符串),以对象的形式描述一个组件)</p>
<pre><code class="language-javaScript">&lt;html&gt;
&lt;body&gt;
    &lt;div id=&quot;app9&quot;&gt;
        &lt;button-counter&gt;&lt;/button-counter&gt;          &lt;!--组件标签--&gt;
    &lt;/div&gt;
&lt;\body&gt;
&lt;\html&gt;
&lt;script&gt;
        Vue.component('button-counter', {             //Vue组件
            data: function () {   //on:click响应函数
                return {
                    count: 0     //初始化默认
                }
            },
            template: &quot;&lt;button v-on:click='count++'&gt;你点击了{{count}}次&lt;/button&gt;&quot;    //模板,使组件标签拥有模板的作用，我们看到模板是一个button标签，里面自带Vue的v-on绑定函数，让count++，函数在上面的DATA域
        })
        var app9 = new Vue({              //创建Vue对象
            el: &quot;#app9&quot;,                          //元素截获
            data: {                                     //数据对象

            }
        });
&lt;\script&gt;       
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AJAX]]></title>
        <id>https://zhaojunjie-code.github.io/post/ajax/</id>
        <link href="https://zhaojunjie-code.github.io/post/ajax/">
        </link>
        <updated>2021-04-06T13:33:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一天">第一天</h1>
<h2 id="xmlhttprequest对象-ajax的开始">* XMLHttpRequest对象 AJAX的开始</h2>
<pre><code class="language-javaScript">var xmlhttp;
xmlhttp = new XMLHttpRequest();
</code></pre>
<h2 id="向服务器发送请求">向服务器发送请求</h2>
<pre><code class="language-javaScript">xmlhttp.open(method,url,async);
xmlhttp.send(string);
</code></pre>
<p>method: 请求的类型 &quot;GET&quot; OR &quot;POST&quot;<br>
url: 文件在服务器的位置<br>
async：true（异步）false（同步）</p>
<p>string: 仅用于POST请求</p>
<h3 id="当使用get发送信息时发送的信息写在url里面-send">当使用GET发送信息时，发送的信息写在url里面 send()</h3>
<h3 id="当使用post发送信息时发送的信息写在send写在这里">当使用POST发送信息时，发送的信息写在send(写在这里)</h3>
<h3 id="setrequsetheaderheadervalue">setRequsetHeader(header，value)</h3>
<p>添加HTTP头<br>
header: 规定头的名称<br>
value： 规定头的值</p>
<h2 id="服务器响应">服务器响应</h2>
<h4 id="responsetext-获得字符串形式的响应数据">responseText 获得字符串形式的响应数据</h4>
<h4 id="responsexml-获得xml形式的响应数据">responseXML 获得XML形式的响应数据</h4>
<p>通常不是XML，就使用Text</p>
<pre><code class="language-javaScript">document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
</code></pre>
<p>如果是XML,则</p>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script&gt;
function loadXMLDoc()
{
  var xmlhttp;
  var txt,x,i;
  if (window.XMLHttpRequest)
  {
    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();
  }
  else
  {
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  xmlhttp.onreadystatechange=function()
  {
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
    {
      xmlDoc=xmlhttp.responseXML;
      txt=&quot;&quot;;
      x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);
      for (i=0;i&lt;x.length;i++)
      {
        txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;
      }
      document.getElementById(&quot;myDiv&quot;).innerHTML=txt;
    }
  }
  xmlhttp.open(&quot;GET&quot;,&quot;cd_catalog.xml&quot;,true);
  xmlhttp.send();
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;h2&gt;我收藏的 CD :&lt;/h2&gt;
&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;
&lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;获取我的 CD&lt;/button&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="onreadystatechange-事件-通常被绑定一个服务器响应函数">onreadystatechange 事件 通常被绑定一个服务器响应函数</h2>
<p>当open,send这些请求发送到服务器是，，服务器会返回响应<br>
onreadystatechange事件类似与onclick事件<br>
每当鼠标点击会触发onclick事件</p>
<h4 id="每当readystate改变时onreadystatechage会被触发一次">每当readyState改变时，onreadystatechage会被触发一次</h4>
<h3 id="readystate-存有xmlhttprequest的状态0-4之间变化">readyState  存有XMLHttpRequest的状态，0-4之间变化</h3>
<p>0：请求未初始化<br>
1：服务器连接已建立<br>
2：请求已接收<br>
3：请求处理中<br>
4：请求已完成，且响应已就绪</p>
<h3 id="status-存储状态">status 存储状态</h3>
<p>200：&quot;OK&quot;<br>
404: 未找到页面<br>
在onreadystatechange事件中，当readyState等于4且状态为200，表示响应就绪</p>
<pre><code class="language-javaScript">if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)     //当服务器响应成功
    {
        document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;   //前端要干的事
    }
</code></pre>
<h3 id="回调函数">回调函数</h3>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
var xmlhttp;
function loadXMLDoc(url,cfunc)
{
if (window.XMLHttpRequest)
  {// IE7+, Firefox, Chrome, Opera, Safari 代码
  xmlhttp=new XMLHttpRequest();
  }
else
  {// IE6, IE5 代码
  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
xmlhttp.onreadystatechange=cfunc;
xmlhttp.open(&quot;GET&quot;,url,true);
xmlhttp.send();
}
function myFunction()
{
	loadXMLDoc(&quot;/try/ajax/ajax_info.txt&quot;,function()             //调用上面的函数
	{
		if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
		{
			document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
		}
	});
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;使用 AJAX 修改文本内容&lt;/h2&gt;&lt;/div&gt;
&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;修改内容&lt;/button&gt;    //绑定自己调用的函数

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="与后台交互-documentgetelementbyidtxthintinnerhtmlxmlhttpresponsetext">与后台交互 document.getElementById(&quot;txtHint&quot;).innerHTML=xmlhttp.responseText;</h2>
<pre><code class="language-javaScript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script&gt;
function showCustomer(str)
{
  var xmlhttp;    
  if (str==&quot;&quot;)                 //开始状态，或者没有值
  {
    document.getElementById(&quot;txtHint&quot;).innerHTML=&quot;&quot;;
    return;               //直接结束
  }
  if (window.XMLHttpRequest)
  {
    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();            //创建一个XMLHttpRequest对象
  }
  else
  {
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/getcustomer.php?q=&quot;+str,true);   //通过GET方法向服务器请求（发送的信息就在url后面加上）这里是 &quot;...q=&quot; +str
  xmlhttp.send();
  xmlhttp.onreadystatechange=function()     //绑定服务器响应函数  ，根据readyState的变化，调用onreadystatechange
  {
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    //响应成功的标志
    {
      document.getElementById(&quot;txtHint&quot;).innerHTML=xmlhttp.responseText;    //从服务器得到数据
    }
  }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;form action=&quot;&quot;&gt; 
&lt;select name=&quot;customers&quot; onchange=&quot;showCustomer(this.value)&quot; style=&quot;font-family:Verdana, Arial, Helvetica, sans-serif;&quot;&gt;   //下拉列表
&lt;option value=&quot;APPLE&quot;&gt;Apple Computer, Inc.&lt;/option&gt;
&lt;option value=&quot;BAIDU &quot;&gt;BAIDU, Inc&lt;/option&gt;
&lt;option value=&quot;Canon&quot;&gt;Canon USA, Inc.&lt;/option&gt;
&lt;option value=&quot;Google&quot;&gt;Google, Inc.&lt;/option&gt;
&lt;option value=&quot;Nokia&quot;&gt;Nokia Corporation&lt;/option&gt;
&lt;option value=&quot;SONY&quot;&gt;Sony Corporation of America&lt;/option&gt;
&lt;/select&gt;
&lt;/form&gt;
&lt;br&gt;
&lt;div id=&quot;txtHint&quot;&gt;客户信息将显示在这...&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS实现完美的拖拽]]></title>
        <id>https://zhaojunjie-code.github.io/post/js-shi-xian-wan-mei-de-tuo-zhuai/</id>
        <link href="https://zhaojunjie-code.github.io/post/js-shi-xian-wan-mei-de-tuo-zhuai/">
        </link>
        <updated>2021-04-02T08:19:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="预备知识">预备知识</h1>
<p>##event事件对象</p>
<h3 id="与光标有关的属性-clientx">与光标有关的属性 clientX</h3>
<p>返回当事件被触发时，鼠标的水平坐标(距离 px)</p>
<h3 id="与光标有关的属性-clienty">与光标有关的属性 clientY</h3>
<p>返回当事件被触发时，鼠标的垂直坐标(距离 px)</p>
<h2 id="html元素对象">HTML元素对象</h2>
<h3 id="offsetleft">offsetLeft</h3>
<p>当前元素相对与最近定位的父元素的水平距离(px)</p>
<h3 id="offsettop">offsetTop</h3>
<p>当前元素相对与最近定位的父元素的垂直距离(px)</p>
<h1 id="跟随鼠标">跟随鼠标</h1>
<p>每当提到控制DOM跟随鼠标移动，我们头脑里会蹦出PageX,PageY 它们俩分别返回当前光标的水平坐标和垂直坐标。</p>
<pre><code class="language-javaScript">var left = event.pageX;
var top = event.pageY;
box1.style.left = left + &quot;px&quot;;
box1.style.top = top +&quot;px&quot;;
</code></pre>
<p>这很容易实现</p>
<h2 id="当我们将上述操作应用到拖拽操作时">当我们将上述操作应用到拖拽操作时</h2>
<p>我们会发现，点击一个元素的某一位置进行拖拽时，元素总会跳变到跟随鼠标移动的位置<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617353505592.png" alt="" loading="lazy"><br>
这导致用户体验感极差<br>
如何解决这个问题呢？<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617354112330.png" alt="" loading="lazy"><br>
我们可以看到</p>
<h3 id="clientx-offsetleft-水平跳变距离">clientX - offsetLeft = 水平跳变距离</h3>
<h3 id="同理-clienty-offsettop-垂直跳变距离">同理 clientY - offsetTop = 垂直跳变距离</h3>
<pre><code class="language-javaScript">box1.onmousedown = function (event) {
               var ol = event.clientX - box1.offsetLeft;
               var ot = event.clientY - box1.offsetTop;
               document.onmousemove = function (event) {
                   var X = event.pageX - ol;
                   var Y = event.pageY - ot;
                   box1.style.left = X + &quot;px&quot;;
                   box1.style.top = Y + &quot;px&quot;;
               }
           }
</code></pre>
<p>我们不希望看到跳变，那么就减去跳变距离</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS实现先阅读协议，后注册]]></title>
        <id>https://zhaojunjie-code.github.io/post/js-shi-xian-xian-yue-du-xie-yi-hou-zhu-ce/</id>
        <link href="https://zhaojunjie-code.github.io/post/js-shi-xian-xian-yue-du-xie-yi-hou-zhu-ce/">
        </link>
        <updated>2021-04-01T11:42:37.000Z</updated>
        <content type="html"><![CDATA[<p>每当我们想注册账号，或者安装软件时，总有一些细致严谨的公司，他们让你在安装前阅读长长的协议。这背后的原理是什么呢？<br>
我们先应该了解JS里的 scrollHeight(文档内容实际高度，包括超出视窗的溢出部分)，scrollTop(滚动条相对于文档顶部的高度，即：滚动距离)，clientHeight(窗口的高度) 属性。</p>
<h1 id="scrollheight">scrollHeight()</h1>
<p>scrollHeight()是window的属性<br>
它是指：文档内容的实际高度，一个网页从页头到页尾。</p>
<h1 id="scrolltop">scrollTop()</h1>
<p>scrollTop()也是window的属性<br>
它是指：垂直滚动条滚动的距离，滚动条下拉的距离。</p>
<h1 id="clientheight">clientHeight()</h1>
<p>clientHeight()是window的属性<br>
翻译过来就很理解：用户所能看到的高度。<br>
<img src="https://zhaojunjie-code.github.io//post-images/1617280221051.png" alt="" loading="lazy"><br>
现在我们应该可以理解背后的原理了吧</p>
<h1 id="就是当红框框到底的时候即-scrollheight-scrolltop-clientheight">就是当红框框到底的时候，即       scrollHeight - scrollTop = clientHeight</h1>
<pre><code class="language-javaScript">					//检查垂直滚动条是否滚动到底
 				if(info.scrollHeight - info.scrollTop == info.clientHeight){
 					//滚动条滚动到底，使表单项可用
 					/*
 					 * disabled属性可以设置一个元素是否禁用，
 					 * 	如果设置为true，则元素禁用
 					 * 	如果设置为false，则元素可用
 					 */
 					inputs[0].disabled = false;
 					inputs[1].disabled = false;
 				}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次使用Gridea]]></title>
        <id>https://zhaojunjie-code.github.io/post/di-yi-ci-shi-yong-gridea/</id>
        <link href="https://zhaojunjie-code.github.io/post/di-yi-ci-shi-yong-gridea/">
        </link>
        <updated>2021-03-31T16:05:56.000Z</updated>
        <content type="html"><![CDATA[<p>2021/4/1 0:08<br>
终于写下了第一篇博客，为前端的学习做好了准备<br>
<em>斜体字</em><br>
<strong>粗体字</strong><br>
<em><strong>粗斜体文本</strong></em><br>
<em>插入斜线</em></p>
<hr>
<p><s>删除文字</s><br>
<u>带上下划线</u><br>
<em>添加脚注</em><br>
长沙理工大学<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>有序列表与无序列表，一定要有一个空格</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第三项</li>
<li>第四项</li>
<li>第五项</li>
</ul>
<ul>
<li>第六项</li>
<li>第七项</li>
<li>第八项</li>
</ul>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
<li>第四项，嵌套使用
<ul>
<li>新的一项，要留四个空格</li>
<li>新的一项，要留四个空格</li>
</ul>
</li>
</ol>
<blockquote>
<p>区块</p>
<blockquote>
<p>第一次嵌套</p>
<blockquote>
<p>第二次嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
</blockquote>
<p>列表中使用区块</p>
<ol>
<li>
<p>第一项</p>
<blockquote>
<p>第一区块<br>
第二区块<br>
第三区块</p>
</blockquote>
</li>
<li>
<p>第二项</p>
<blockquote>
<p>第一区块<br>
第二区块<br>
第三区块</p>
</blockquote>
</li>
</ol>
<p>代码区块,三个漂符，可以指定语言也可不指定语言<br>
<code>printf()</code> 函数</p>
<pre><code class="language-javaScript">$(document).ready(function () {
    alert('RUNOOB');
});
</code></pre>
<p>基本的链接使用方法<br>
这是一个<a href="https://www.runoob.com">菜鸟教程</a>的链接<br>
高级使用方法<br>
用1设置链接变量<br>
这是一个链接 [菜鸟教程][1]<br>
[1]:  https://www.runoob.com/<br>
两种显示出图片的方法<br>
<img src="http://static.runoob.com/images/runoob-logo.png" alt="这里填显示不出来的代替文字" loading="lazy"><br>
<img src="http://static.runoob.com/images/runoob-logo.png" width="50%"></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>双非大学 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>